diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
index 1a00462..9215190 100644
--- a/.vscode/c_cpp_properties.json
+++ b/.vscode/c_cpp_properties.json
@@ -1,21 +1,18 @@
 {
-    "configurations": [
-        {
-            "name": "linux-gcc-x64",
-            "includePath": [
-                "${workspaceFolder}/**"
-            ],
-            "compilerPath": "/usr/bin/gcc",
-            "cStandard": "${default}",
-            "cppStandard": "${default}",
-            "intelliSenseMode": "linux-gcc-x64",
-            "compilerArgs": [
-                "-Wall",
-                "-Wextra",
-                "-Wpedantic"
-            ],
-            "configurationProvider": "ms-vscode.makefile-tools"
-        }
-    ],
-    "version": 4
+  "configurations": [
+    {
+      "name": "linux-gcc-x64",
+      "includePath": [
+        
+        "/home/parallels/Desktop/dolphin2/include/**"
+      ],
+      "compilerPath": "/usr/bin/gcc",
+      "cStandard": "${default}",
+      "cppStandard": "${default}",
+      "intelliSenseMode": "linux-gcc-x64",
+      "compilerArgs": [],
+      "configurationProvider": "ms-vscode.makefile-tools"
+    }
+  ],
+  "version": 4
 }
\ No newline at end of file
diff --git a/.vscode/dryrun.log b/.vscode/dryrun.log
index 2c946de..256d513 100644
--- a/.vscode/dryrun.log
+++ b/.vscode/dryrun.log
@@ -1,6 +1,5 @@
 make --dry-run --always-make --keep-going --print-directory
 make: Entering directory '/root/benjixu/dolphin2'
- 
 for dir in /root/benjixu/dolphin2/boot/ /root/benjixu/dolphin2/kernel/drives/usb/ /root/benjixu/dolphin2/kernel/ /root/benjixu/dolphin2/build/	;	\
 do	\
 	make -C $dir;	\
diff --git a/.vscode/extensions.json b/.vscode/extensions.json
new file mode 100644
index 0000000..ea5c4fc
--- /dev/null
+++ b/.vscode/extensions.json
@@ -0,0 +1,5 @@
+{
+    "recommendations": [
+        "mitaki28.vscode-clang"
+    ]
+}
\ No newline at end of file
diff --git a/.vscode/launch.json b/.vscode/launch.json
index 56f6d95..e577889 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -1,65 +1,52 @@
-/*{
-    // 使用 IntelliSense 了解相关属性。 
-    // 悬停以查看现有属性的描述。
-    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
-    "version": "0.2.0",
-    "configurations": [
-        {
-            "name": "gcc - 生成和调试活动文件",
-            "type": "cppdbg",
-            "request": "launch",
-            "program": "${fileDirname}/${fileBasenameNoExtension}",
-            "args": [],
-            "stopAtEntry": false,
-            "cwd": "${fileDirname}",
-            "environment": [],
-            "externalConsole": false,
-            "MIMode": "gdb",
-            "setupCommands": [
-                {
-                    "description": "为 gdb 启用整齐打印",
-                    "text": "-enable-pretty-printing",
-                    "ignoreFailures": true
-                }
-            ],
-            "preLaunchTask": "C/C++: gcc 生成活动文件",
-            "miDebuggerPath": "/usr/bin/gdb"
-        }
-    ]
-}
-*/
-
 {
-    // Use IntelliSense to learn about possible attributes.
-    // Hover to view descriptions of existing attributes.
-    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
-    "version": "0.2.0",
-    "configurations": [
+  "version": "0.2.0",
+  "configurations": [
     {
-    "name": "GDB debug",
-    "type": "cppdbg",
-    "request": "launch",
-    "program": "${workspaceFolder}/build/amd64/kernel8.elf",
-    "args": [],
-    "stopAtEntry": true,
-    "cwd": "${workspaceFolder}/kernel/aarch/amd64",
-    "includePath": ["${workspaceFolder}/kernel/aarch/amd64"],
-    //"sourceFileMap": {"./aarch/amd64":"${workspaceFolder}/kernel/aarch/amd64"},
-    "environment": [],
-    "externalConsole": false,
-    "MIMode": "gdb",
-    //"targetArchitecture": "x86",
- //   "preLaunchTask": "build",
-    "setupCommands":
-    [
+      "name": "GDB debug",
+      "type": "cppdbg",
+      "request": "launch",
+      "program": "${workspaceFolder}/build/arm/kernel8.elf",
+      "args": [],
+      "stopAtEntry": true,
+      "cwd": "${workspaceFolder}/kernel/arch/arm",
+      "includePath": [
+        "${workspaceFolder}/kernel/arch/arm"
+      ],
+      "environment": [],
+      "externalConsole": false,
+      "MIMode": "gdb",
+      "setupCommands": [
+        {
+          "description": "Enable pretty-printing for gdb",
+          "text": "-enable-pretty-printing",
+          "ignoreFailures": true
+        }
+      ],
+      "miDebuggerPath": "/usr/bin/gdb-multiarch",
+      "miDebuggerServerAddress": "localhost:1234"
+    },
     {
-    "description": "Enable pretty-printing for gdb",
-    "text": "-enable-pretty-printing",
-    "ignoreFailures": true
-    }
-    ],
-    "miDebuggerPath": "/usr/bin/gdb-multiarch",
-    "miDebuggerServerAddress": "localhost:1234"
+      "name": "C/C++ Runner: Debug Session",
+      "type": "cppdbg",
+      "request": "launch",
+      "args": [
+        ""
+      ],
+      "stopAtEntry": false,
+      "cwd": "/home/parallels/Desktop/dolphin2/kernel/arch/arm",
+      "environment": [],
+      "program": "/home/parallels/Desktop/dolphin2/kernel/arch/arm/build/Debug/outDebug",
+      "internalConsoleOptions": "openOnSessionStart",
+      "MIMode": "gdb",
+      "miDebuggerPath": "gdb",
+      "externalConsole": false,
+      "setupCommands": [
+        {
+          "description": "Enable pretty-printing for gdb",
+          "text": "-enable-pretty-printing",
+          "ignoreFailures": true
+        }
+      ]
     }
-    ]
-    }
\ No newline at end of file
+  ]
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
index bcc585b..e2a0cc1 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -1,11 +1,42 @@
 {
-    "makefile.extensionOutputFolder": "./.vscode",
-    "files.associations": {
-        "gpio.h": "c",
-        "stdarg.h": "c",
-        "stdint.h": "c",
-        "printk.h": "c"
-    },
-    
-    "C_Cpp.dimInactiveRegions": false
+  "makefile.extensionOutputFolder": "./.vscode",
+  "files.associations": {
+    "gpio.h": "c",
+    "stdarg.h": "c",
+    "stdint.h": "c",
+    "printk.h": "c"
+  },
+  "clang.cflags": [
+    "-I/home/parallels/Desktop/dolphin2/include"
+  ],
+  "C_Cpp.dimInactiveRegions": false,
+  "C_Cpp.errorSquiggles": "Disabled",
+  "C_Cpp_Runner.cCompilerPath": "/usr/bin/gcc",
+  "C_Cpp_Runner.cppCompilerPath": "/usr/bin/g++",
+  "C_Cpp_Runner.debuggerPath": "gdb",
+  "C_Cpp_Runner.cStandard": "",
+  "C_Cpp_Runner.cppStandard": "",
+  "C_Cpp_Runner.msvcBatchPath": "",
+  "C_Cpp_Runner.warnings": [
+    "-Wall",
+    "-Wextra",
+    "-Wpedantic"
+  ],
+  "C_Cpp_Runner.enableWarnings": true,
+  "C_Cpp_Runner.warningsAsError": false,
+  "C_Cpp_Runner.compilerArgs": [],
+  "C_Cpp_Runner.linkerArgs": [],
+  "C_Cpp_Runner.includePaths": [],
+  "C_Cpp_Runner.includeSearch": [
+    "*",
+    "**/*"
+  ],
+  "C_Cpp_Runner.excludeSearch": [
+    "**/build",
+    "**/build/**",
+    "**/.*",
+    "**/.*/**",
+    "**/.vscode",
+    "**/.vscode/**"
+  ]
 }
\ No newline at end of file
diff --git a/.vscode/targets.log b/.vscode/targets.log
index 3c9c919..defe544 100644
--- a/.vscode/targets.log
+++ b/.vscode/targets.log
@@ -6,7 +6,7 @@ make all --print-data-base --no-builtin-variables --no-builtin-rules --question
 # This is free software: you are free to change and redistribute it.
 # There is NO WARRANTY, to the extent permitted by law.
 
-# Make data base, printed on Fri Jan 21 23:08:49 2022
+# Make data base, printed on Fri Feb  4 17:31:18 2022
 
 # Variables
 
@@ -69,7 +69,7 @@ LESSOPEN = | /usr/bin/lesspipe %s
 # environment
 VSCODE_CWD = /root
 # environment
-SSH_CONNECTION = 71.187.230.215 60642 104.244.92.245 22
+SSH_CONNECTION = 68.197.157.226 52894 104.244.92.245 488
 # environment
 PATH = /root/.vscode-server/bin/899d46d82c4c95423fb7e10e68eba52050e30ba3/bin:/root/.vscode-server/bin/899d46d82c4c95423fb7e10e68eba52050e30ba3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/environment/jdk-11.0.12+7:/usr/local/cross-compiler/bin:/snap/bin:/usr/environment/jdk-11.0.12+7/bin:/usr/environment/jdk-11.0.12+7/jre/bin:/usr/environment/apache-maven-3.6.3:/usr/environment/apache-maven-3.6.3/bin/:/usr/environment/jdk-11.0.12+7/bin:/usr/environment/jdk-11.0.12+7/jre/bin:/usr/environment/apache-maven-3.6.3:/usr/environment/apache-maven-3.6.3/bin/:/usr/environment/jdk-11.0.12+7/bin:/usr/environment/jdk-11.0.12+7/jre/bin:/usr/environment/apache-maven-3.6.3:/usr/environment/apache-maven-3.6.3/bin/:/usr/environment/jdk-11.0.12+7/bin:/usr/environment/jdk-11.0.12+7/jre/bin:/usr/environment/apache-maven-3.6.3:/usr/environment/apache-maven-3.6.3/bin/
 # environment
@@ -93,7 +93,7 @@ VSCODE_PIPE_LOGGING = true
 # environment
 PWD = /root/benjixu/dolphin2
 # environment
-VSCODE_IPC_HOOK_CLI = /run/user/0/vscode-ipc-695e59f5-60e3-478c-bc3a-c62a8743c81e.sock
+VSCODE_IPC_HOOK_CLI = /run/user/0/vscode-ipc-5056a81c-16bc-47ac-81ea-37fb821e211b.sock
 # automatic
 *D = $(patsubst %/,%,$(dir $*))
 # makefile (from 'config.mk', line 4)
@@ -149,13 +149,13 @@ MAKE_COMMAND := make
 # automatic
 *F = $(notdir $*)
 # makefile (from 'config.mk', line 2)
-ARCH = x86
+target = x86
 # makefile
 MAKEFLAGS = pqrR
 # environment
 MFLAGS = -pqrR
 # environment
-SSH_CLIENT = 71.187.230.215 60642 22
+SSH_CLIENT = 68.197.157.226 52894 488
 # environment
 MAIL = /var/mail/root
 # makefile (from 'makefile', line 5)
@@ -169,7 +169,7 @@ MAKEFILES :=
 # automatic
 <F = $(notdir $<)
 # makefile (from 'makefile', line 9)
-AARCH = aarch/amd64
+AARCH = arch/amd64
 # environment
 LC_ALL = C
 # automatic
@@ -210,7 +210,7 @@ VSCODE_EXTHOST_WILL_SEND_SOCKET = true
 # Not a target:
 config.mk:
 #  Implicit rule search has been done.
-#  Last modified 2022-01-19 00:18:04.420543331
+#  Last modified 2022-02-04 16:51:43.091048601
 #  File has been updated.
 #  Successfully updated.
 
@@ -278,6 +278,7 @@ run: all
 #  recipe to execute (from 'makefile', line 34):
 	$(RUNNING_INSTURCTION)
 
+ 
 clean:
 #  Implicit rule search has not been done.
 #  Modification time never checked.
@@ -299,7 +300,6 @@ clean:
 
 # No 'vpath' search paths.
 
- 
 # No general ('VPATH' variable) search path.
 
 # strcache buffers: 1 (0) / strings = 26 / storage = 196 B / avg = 7 B
@@ -308,6 +308,6 @@ clean:
 # strcache performance: lookups = 40 / hit rate = 35%
 # hash-table stats:
 # Load=26/8192=0%, Rehash=0, Collisions=1/40=2%
-# Finished Make data base on Fri Jan 21 23:08:49 2022
+# Finished Make data base on Fri Feb  4 17:31:18 2022
 
  
diff --git a/README.md b/README.md
index 70fc40c..adc891f 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,6 @@
 # dolphin2
+    I am going to design a kernel running in both x64 and arm64
+    This kernel based on DolphinOS.
     设计一个可以在树莓派上运行又可以在X86平台上运行的内核
     这是在DolphinOS的基础上继续开发
     因为DolphinOS只支持X86所以我扩充了arm版本
diff --git a/boot/aarch/arm/start.S b/boot/aarch/arm/start.S
deleted file mode 100644
index 45c6cf4..0000000
--- a/boot/aarch/arm/start.S
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2018 bzt (bztsrc@github)
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-.section ".text.boot"
-
-.global _start
-
-_start:
-    // read cpu id, stop slave cores
-    mrs     x1, mpidr_el1
-    and     x1, x1, #3
-    cbz     x1, 2f
-    // cpu id > 0, stop
-1:  wfe
-    b       1b
-2:  // cpu id == 0
-
-    // set stack before our code
-    ldr     x1, =_start
-    mov     sp, x1
-
-    // clear bss
-    ldr     x1, =__bss_start
-    ldr     w2, =__bss_size
-3:  cbz     w2, 4f
-    str     xzr, [x1], #8
-    sub     w2, w2, #1
-    cbnz    w2, 3b
-
-    // jump to C code, should not return
-4:  bl      kernel_init
-    // for failsafe, halt this core too
-    b       1b
diff --git a/boot/aarch/amd64/boot.asm b/boot/arch/amd64/boot.asm
similarity index 100%
rename from boot/aarch/amd64/boot.asm
rename to boot/arch/amd64/boot.asm
diff --git a/boot/aarch/amd64/load.asm b/boot/arch/amd64/load.asm
similarity index 100%
rename from boot/aarch/amd64/load.asm
rename to boot/arch/amd64/load.asm
diff --git a/boot/aarch/amd64/load.sh b/boot/arch/amd64/load.sh
similarity index 100%
rename from boot/aarch/amd64/load.sh
rename to boot/arch/amd64/load.sh
diff --git a/boot/aarch/amd64/makefile b/boot/arch/amd64/makefile
similarity index 100%
rename from boot/aarch/amd64/makefile
rename to boot/arch/amd64/makefile
diff --git a/boot/aarch/arm/makefile b/boot/arch/arm/makefile
similarity index 100%
rename from boot/aarch/arm/makefile
rename to boot/arch/arm/makefile
diff --git a/boot/arch/arm/start.S b/boot/arch/arm/start.S
new file mode 100644
index 0000000..9ec4391
--- /dev/null
+++ b/boot/arch/arm/start.S
@@ -0,0 +1,54 @@
+.section ".text.boot"
+.global start
+
+
+start:
+    mrs x0, mpidr_el1
+    and x0, x0, #3
+    cmp x0, #0
+    beq kernel_entry
+
+end:
+    b end
+
+kernel_entry:
+    mrs x0, currentel
+    lsr x0, x0, #2
+    cmp x0, #2
+    bne end
+
+    msr sctlr_el1, xzr
+    mov x0, #(1 << 31)
+    msr hcr_el2, x0
+
+    mov x0, #0b1111000101
+    msr spsr_el2, x0
+
+    adr x0, el1_entry
+    msr elr_el2, x0
+
+    eret
+
+el1_entry:
+    mov sp, #0x80000
+
+    bl setup_vm
+    bl enable_mmu
+
+    ldr x0, =bss_start
+    ldr x1, =bss_end
+    sub x2, x1, x0
+    mov x1, #0
+    bl memset
+
+    ldr x0, =vector_table
+    msr vbar_el1, x0
+    
+    mov x0, #0xffff000000000000
+    add sp, sp, x0
+
+    ldr x0, =kernel_init
+    blr x0
+
+    b end
+    
\ No newline at end of file
diff --git a/build/amd64/boot.img b/build/amd64/boot.img
index 03967ef..08f3dc5 100644
Binary files a/build/amd64/boot.img and b/build/amd64/boot.img differ
diff --git a/build/amd64/makefile b/build/amd64/makefile
index 6c58d83..f57a822 100644
--- a/build/amd64/makefile
+++ b/build/amd64/makefile
@@ -3,7 +3,7 @@ BIN			= kernel.bin
 cp:dd
 	cp boot.img ../../file/ 
 	cp kernel8.elf ../../file/
-	objdump $(DISASSEMBLY) > $(PROJECT_DIR)/file/debug.asm
+	$(OBJDUMP) $(DISASSEMBLY) > $(PROJECT_DIR)/file/debug.asm
 dd:bootdd
 	dd if=kernel.bin of=boot.img bs=512 count=100 seek=6 conv=notrunc 
 
diff --git a/build/arm/makefile b/build/arm/makefile
index e4658b6..05462bc 100644
--- a/build/arm/makefile
+++ b/build/arm/makefile
@@ -1,5 +1,8 @@
 BIN = kernel8.img
 
+disassembly:cp
+	$(OBJDUMP) $(DISASSEMBLY) > $(PROJECT_DIR)/file/debug.S
+
 cp:all
 	cp kernel8.elf $(PROJECT_DIR)/file/
 	cp kernel8.img $(PROJECT_DIR)/file/
diff --git a/build/makefile b/build/makefile
index 53def42..e639563 100644
--- a/build/makefile
+++ b/build/makefile
@@ -1,8 +1,8 @@
 
-ifeq ($(ARCH),x86)
+ifeq ($(target),x86)
 	DIR = amd64
 endif
-ifeq ($(ARCH),arm)
+ifeq ($(target),arm)
 	DIR = arm
 endif
 
diff --git a/config.mk b/config.mk
index 93c26bf..7f8beb7 100644
--- a/config.mk
+++ b/config.mk
@@ -1,9 +1,9 @@
 #The computer architecture. 
-export ARCH 	  		 = x86
+export target 	  		 = arm
 export PROJECT_DIR		 = $(shell pwd)
-export DEBUG_FILE		 = trap.o
+export DEBUG_FILE		 = init.o
 export OPTIMIZATION		 = -O0
-export VIRTUAL_MEMORY	 = 512
+export VIRTUAL_MEMORY	 = 1024
 
 BUILD_DIR				 = $(PROJECT_DIR)/boot/	\
 						   $(PROJECT_DIR)/kernel/drives/usb/	\
diff --git a/include/amd64/register.h b/include/amd64/register.h
new file mode 100644
index 0000000..6488b09
--- /dev/null
+++ b/include/amd64/register.h
@@ -0,0 +1,12 @@
+#ifndef _REGISTER_H
+#define _REGISTER_H
+#include "amd64/trap.h"
+#include "stdint.h"
+
+//64为任务总数，registerList表示任务数组
+struct TrapFrame registerList[64];
+
+void set_task_register(int pid, uint64_t functionAddress);
+void save_registers(struct TrapFrame *curThread, struct TrapFrame *tf);
+
+#endif
diff --git a/include/arm/handler.h b/include/arm/handler.h
new file mode 100644
index 0000000..110a8f4
--- /dev/null
+++ b/include/arm/handler.h
@@ -0,0 +1,8 @@
+#ifndef _HANDLER_H
+#define _HANDLER_H
+
+//void init_interrupt_controller(void);
+void init_timer(void);
+void enable_irq(void);
+
+#endif
\ No newline at end of file
diff --git a/include/arm/homer.h b/include/arm/homer.h
deleted file mode 100644
index 02b2d70..0000000
--- a/include/arm/homer.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*  GIMP header image file format (RGB)  */
-
-static unsigned int homer_width = 1024;
-static unsigned int homer_height = 768;
-
-/*  Call this macro repeatedly.  After each use, the pixel data can be extracted  */
-
-#define HEADER_PIXE(data,pixel) {\
-pixel[0] = (((data[0] - 33) << 2) | ((data[1] - 33) >> 4)); \
-pixel[1] = ((((data[1] - 33) & 0xF) << 4) | ((data[2] - 33) >> 2)); \
-pixel[2] = ((((data[2] - 33) & 0x3) << 6) | ((data[3] - 33))); \
-data += 4; \
-}
diff --git a/include/arm/irq.h b/include/arm/irq.h
new file mode 100644
index 0000000..78fc577
--- /dev/null
+++ b/include/arm/irq.h
@@ -0,0 +1,19 @@
+#ifndef _IRQ_H
+#define _IRQ_H
+
+#include "memory.h"
+
+#define CNTP_EL0	        P2V(0x40000040)
+#define CNTP_STATUS_EL0     P2V(0x40000060)
+
+#define BASE_ADDR           P2V(0x3f000000)
+
+#define IRQ_BASIC_PENDING	(BASE_ADDR + 0xB200)
+#define ENABLE_IRQS_1		(BASE_ADDR + 0xB210)
+#define ENABLE_IRQS_2		(BASE_ADDR + 0xB214)
+#define ENABLE_BASIC_IRQS	(BASE_ADDR + 0xB218)
+#define DISABLE_IRQS_1		(BASE_ADDR + 0xB21C)
+#define DISABLE_IRQS_2		(BASE_ADDR + 0xB220)
+#define DISABLE_BASIC_IRQS	(BASE_ADDR + 0xB224)
+ 
+ #endif
\ No newline at end of file
diff --git a/include/arm/lib.h b/include/arm/lib.h
new file mode 100644
index 0000000..abbbf09
--- /dev/null
+++ b/include/arm/lib.h
@@ -0,0 +1,16 @@
+#ifndef _LIB_H
+#define _LIB_H
+
+#include "stdint.h"
+
+void delay(uint64_t value);
+void out_word(uint64_t addr, uint32_t value);
+uint32_t in_word(uint64_t addr);
+
+void memset(void *dst, int value, unsigned int size);
+void memcpy(void *dst, void *src, unsigned int size);
+void memmove(void *dst, void *src, unsigned int size);
+int memcmp(void *src1, void *src2, unsigned int size);
+unsigned char get_el(void);
+
+#endif
\ No newline at end of file
diff --git a/include/arm/mapping.h b/include/arm/mapping.h
new file mode 100644
index 0000000..dc40cd5
--- /dev/null
+++ b/include/arm/mapping.h
@@ -0,0 +1,46 @@
+#ifndef __MAPPING_H
+#define __MAPPING_H
+#include "stdint.h"
+#include "arm/memory.h"
+
+enum state
+{
+    FREE = 0,
+    IN_USE = 1,
+    USED = 2
+};
+
+enum attributes
+{
+    DIR0 = 0,
+    DIR1 = 1,
+    DIR2 = 2
+};
+
+enum procedure_type
+{
+    KERNEL = 0,
+    NORMAL_PROCESS = 1
+};
+
+struct page_dir_manage
+{
+    enum state dirState; //此页目录的状态，FREE是没有被使用，IN_USE是正在使用，USED是已经使用完了
+    uint64_t address;
+    uint64_t usedAmount;
+    enum attributes attri;
+    struct page_dir_manage *next;
+};
+
+struct page_infor
+{
+    uint64_t virtualAddress; //必须是2mb对齐
+    struct page *pPhysicalAdrress;
+    uint64_t dirAddress;
+};
+
+uint64_t find_physical_address();
+uint64_t mapping(uint64_t dirAddress, uint64_t index, uint64_t address, enum attributes attris);
+void free_page(uint64_t pageAmount);
+
+#endif
\ No newline at end of file
diff --git a/include/arm/mbox.h b/include/arm/mbox.h
deleted file mode 100644
index 09844de..0000000
--- a/include/arm/mbox.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2018 bzt (bztsrc@github)
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-/* a properly aligned buffer */
-extern volatile unsigned int mbox[36];
-
-#define MBOX_REQUEST    0
-
-/* channels */
-#define MBOX_CH_POWER   0
-#define MBOX_CH_FB      1
-#define MBOX_CH_VUART   2
-#define MBOX_CH_VCHIQ   3
-#define MBOX_CH_LEDS    4
-#define MBOX_CH_BTNS    5
-#define MBOX_CH_TOUCH   6
-#define MBOX_CH_COUNT   7
-#define MBOX_CH_PROP    8
-
-/* tags */
-#define MBOX_TAG_GETSERIAL      0x10004
-#define MBOX_TAG_SETCLKRATE     0x38002
-#define MBOX_TAG_LAST           0
-
-int mbox_call(unsigned char ch);
diff --git a/include/arm/memory.h b/include/arm/memory.h
new file mode 100644
index 0000000..01fd775
--- /dev/null
+++ b/include/arm/memory.h
@@ -0,0 +1,32 @@
+#ifndef _MEMORY_H
+#define _MEMORY_H
+
+#ifdef MEM
+#define SIZE_MEM MEM
+#endif
+
+#include "stdint.h"
+
+struct page
+{
+    struct page *next;
+};
+
+#define PHYSICAL_MEM_SIZE 256 //单位MB，unit mb
+struct page *pageHead, *pageTail;
+
+#define KERNEL_BASE 0xffff000000000000
+#define MEMORY_END  P2V(0x30000000)
+#define PAGE_SIZE (2*1024*1024)
+
+#define P2V(p) ((uint64_t)(p) + KERNEL_BASE)
+#define V2P(v) ((uint64_t)(v)-KERNEL_BASE)
+
+#define PA_UP(v)    ((((uint64_t)v + PAGE_SIZE - 1) >> 21) << 21)
+#define PA_DOWN(v)  (((uint64_t)v >> 21) << 21)
+
+void init_memory(void);
+static void free_region(uint64_t v, uint64_t e);
+uint64_t link_page(uint64_t address, uint64_t offset);
+
+#endif
diff --git a/include/arm/peripherals/base.h b/include/arm/peripherals/base.h
deleted file mode 100644
index 63f9c03..0000000
--- a/include/arm/peripherals/base.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef	_P_BASE_H
-#define	_P_BASE_H
-
-#define PBASE 0x3F000000
-
-#endif  /*_P_BASE_H */
diff --git a/include/arm/peripherals/gpio.h b/include/arm/peripherals/gpio.h
deleted file mode 100644
index 8472d0a..0000000
--- a/include/arm/peripherals/gpio.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef	_P_GPIO_H
-#define	_P_GPIO_H
-
-#include "arm/peripherals/base.h"
-
-#define GPFSEL1         (PBASE+0x00200004)
-#define GPSET0          (PBASE+0x0020001C)
-#define GPCLR0          (PBASE+0x00200028)
-#define GPPUD           (PBASE+0x00200094)
-#define GPPUDCLK0       (PBASE+0x00200098)
-
-
-#define MMIO_BASE       0x3F000000
-
-#define GPFSEL0         ((volatile unsigned int*)(MMIO_BASE+0x00200000))
-#define GPFSEL1         ((volatile unsigned int*)(MMIO_BASE+0x00200004))
-#define GPFSEL2         ((volatile unsigned int*)(MMIO_BASE+0x00200008))
-#define GPFSEL3         ((volatile unsigned int*)(MMIO_BASE+0x0020000C))
-#define GPFSEL4         ((volatile unsigned int*)(MMIO_BASE+0x00200010))
-#define GPFSEL5         ((volatile unsigned int*)(MMIO_BASE+0x00200014))
-#define GPSET0          ((volatile unsigned int*)(MMIO_BASE+0x0020001C))
-#define GPSET1          ((volatile unsigned int*)(MMIO_BASE+0x00200020))
-#define GPCLR0          ((volatile unsigned int*)(MMIO_BASE+0x00200028))
-#define GPLEV0          ((volatile unsigned int*)(MMIO_BASE+0x00200034))
-#define GPLEV1          ((volatile unsigned int*)(MMIO_BASE+0x00200038))
-#define GPEDS0          ((volatile unsigned int*)(MMIO_BASE+0x00200040))
-#define GPEDS1          ((volatile unsigned int*)(MMIO_BASE+0x00200044))
-#define GPHEN0          ((volatile unsigned int*)(MMIO_BASE+0x00200064))
-#define GPHEN1          ((volatile unsigned int*)(MMIO_BASE+0x00200068))
-#define GPPUD           ((volatile unsigned int*)(MMIO_BASE+0x00200094))
-#define GPPUDCLK0       ((volatile unsigned int*)(MMIO_BASE+0x00200098))
-#define GPPUDCLK1       ((volatile unsigned int*)(MMIO_BASE+0x0020009C))
-
-#endif  /*_P_GPIO_H */
diff --git a/include/arm/register.h b/include/arm/register.h
new file mode 100644
index 0000000..77656f4
--- /dev/null
+++ b/include/arm/register.h
@@ -0,0 +1,50 @@
+#ifndef _REGISTER_H
+#define _REGISTER_H
+#include "stdint.h"
+#include "task.h"
+
+struct trap_frame
+{
+    uint64_t x0;
+    uint64_t x1;
+    uint64_t x2;
+    uint64_t x3;
+    uint64_t x4;
+    uint64_t x5;
+    uint64_t x6;
+    uint64_t x7;
+    uint64_t x8;
+    uint64_t x9;
+    uint64_t x10;
+    uint64_t x11;
+    uint64_t x12;
+    uint64_t x13;
+    uint64_t x14;
+    uint64_t x15;
+    uint64_t x16;
+    uint64_t x17;
+    uint64_t x18;
+    uint64_t x19;
+    uint64_t x20;
+    uint64_t x21;
+    uint64_t x22;
+    uint64_t x23;
+    uint64_t x24;
+    uint64_t x25;
+    uint64_t x26;
+    uint64_t x27;
+    uint64_t x28;
+    uint64_t x29;
+    uint64_t x30;
+    uint64_t sp;
+    uint64_t spsr_el1;
+    uint64_t elr_el1;
+};
+
+
+struct trap_frame registerList[tasksNumber];
+
+
+void save_registers(struct trap_frame *curTask, struct trap_frame *tf, uint64_t elr_el1, uint64_t spsr_el1, uint64_t sp);
+
+#endif
diff --git a/include/arm/uart.h b/include/arm/uart.h
index 1a29465..90940c5 100644
--- a/include/arm/uart.h
+++ b/include/arm/uart.h
@@ -1,35 +1,23 @@
-/*
- * Copyright (C) 2018 bzt (bztsrc@github)
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-#ifndef	_UART_H
-#define	_UART_H
-
-void uart_init();
-void uart_send(unsigned int c);
-char uart_getc();
-void uart_puts(char *s);
-void uart_hex(unsigned int d);
-
-#endif
\ No newline at end of file
+#ifndef _UART_H
+#define _UART_H
+
+#include "memory.h"
+
+#define IO_BASE_ADDR    P2V(0x3f200000)
+
+#define UART0_DR        IO_BASE_ADDR + 0x1000
+#define UART0_FR        IO_BASE_ADDR + 0x1018
+#define UART0_CR        IO_BASE_ADDR + 0x1030
+#define UART0_LCRH      IO_BASE_ADDR + 0x102c
+#define UART0_FBRD      IO_BASE_ADDR + 0x1028
+#define UART0_IBRD      IO_BASE_ADDR + 0x1024
+#define UART0_IMSC      IO_BASE_ADDR + 0x1038
+#define UART0_MIS       IO_BASE_ADDR + 0x1040
+#define UART0_ICR       IO_BASE_ADDR + 0x1044
+
+unsigned char read_char(void);
+void write_char(unsigned char c);
+void write_string(const char *string);
+void init_uart(void);
+
+#endif
diff --git a/include/init.h b/include/init.h
index 8ae22b9..66c64a1 100644
--- a/include/init.h
+++ b/include/init.h
@@ -1,11 +1,14 @@
-/*
- * @Author: your name
- * @Date: 2021-09-27 22:00:13
- * @LastEditTime: 2021-11-02 18:48:32
- * @LastEditors: your name
- * @Description: In User Settings Edit
- * @FilePath: /dolphin2/include/init.h
+/** 
+ * Name: init.h
+ * Author: Benji Xu <benjixu2020@gmail.com>
+ * Date: 2021-11-04 03:56:41
+ * LastEditTime: 2022-01-22 01:28:41
+ * LastEditors: Benji Xu
+ * FilePath: /dolphin2/include/init.h
+ * Description: 
+ * 描述: 
  */
+
 #ifndef	_INIT_H
 #define	_INIT_H
 
diff --git a/include/interruption.h b/include/interruption.h
new file mode 100644
index 0000000..577e343
--- /dev/null
+++ b/include/interruption.h
@@ -0,0 +1,18 @@
+/** 
+ * Name: interruption.h
+ * Author: Benji Xu <benjixu2020@gmail.com>
+ * Date: 2022-01-22 01:11:34
+ * LastEditTime: 2022-01-22 01:48:38
+ * LastEditors: Benji Xu
+ * FilePath: /dolphin2/include/interruption.h
+ * Description: You can use the enable_interruption and disable_interruption to enable and disable the interruption.
+ * 描述: 你可以使用enable_interruption和disable_interruption分别打开和关闭中断
+ */
+
+#ifndef _INTERRUPTION_H
+#define _INTERRUPTION_H
+
+void enable_interruption(void);
+void disable_interruption(void);
+
+#endif
diff --git a/include/amd64/thread.h b/include/task.h
similarity index 65%
rename from include/amd64/thread.h
rename to include/task.h
index c2a4835..7cf8560 100644
--- a/include/amd64/thread.h
+++ b/include/task.h
@@ -1,20 +1,21 @@
 #ifndef _THREAD_H_
 #define _THREAD_H_
-#include "amd64/trap.h"
 #include "stdint.h"
+#define tasksNumber 64
 
 enum task_type
 {
-    THREAD,
+    KERNEL,
     PROCESS,
 };
 
+//我们设置了六种状态，初始值为TASK_WAIITING = 0
 enum task_status
 {
-    TASK_RUNNING,
+    TASK_WAITTING,
     TASK_READY,
     TASK_BLOCKED,
-    TASK_WAITTING,
+    TASK_RUNNING,
     TASK_HANGING,
     TASK_DIED
 };
@@ -26,21 +27,18 @@ struct task_list
     uint32_t pid;
     enum task_type type;
     enum task_status status;
-    struct TrapFrame registerAddress;
     struct task_list *before;
     struct task_list *next;
 };
 
-static struct task_list tasks[64];
-struct TrapFrame registerList[64];
+static struct task_list tasks[tasksNumber];
 
 struct task_list *p;
 struct task_list *tHead;
 
-void init_thread(void);
-void create_thread(char *name, enum task_type type, uint64_t functionAddress);
+void init_task(void);
+void create_task(char *name, enum task_type type, uint64_t functionAddress);
 void set_task_status(char *name, struct task_list *p, uint64_t functionAddress, enum task_type type);
 uint64_t link_task(struct task_list *temp);
-void save_registers(struct TrapFrame *curThread, struct TrapFrame *tf);
 
 #endif
\ No newline at end of file
diff --git a/kernel/aarch/amd64/thread.c b/kernel/aarch/amd64/thread.c
deleted file mode 100644
index 7873e41..0000000
--- a/kernel/aarch/amd64/thread.c
+++ /dev/null
@@ -1,172 +0,0 @@
-#include "stdlib.h"
-#include "printk.h"
-#include "amd64/trap.h"
-#include "amd64/thread.h"
-
-int tasksNum = 0;
-
-void test_print1()
-{
-    while (1)
-    {
-        for (int i = 0; i < 30000000; i++)
-        {
-            /* code */
-        }
-        
-        printk(" 1aa1 ");
-    }
-}
-
-void test_print2()
-{
-    while (1)
-    {
-         for (int i = 0; i < 30000000; i++)
-        {
-            /* code */
-        }
-        printk(" 2bb2 ");
-    }
-}
-
-void test_print3()
-{
-    while (1)
-    {
-         for (int i = 0; i < 30000000; i++)
-        {
-            /* code */
-        }
-        printk(" 3cc3 ");
-    }
-}
-
-void init_thread()
-{
-
-    char name[64] = "000000000";
-    for (int i = 0; i < 64; i++)
-    {
-        tasks[0].name[i] = name[i];
-    }
-    tasks[0].status = TASK_RUNNING;
-    tasks[0].type = THREAD;
-    tasks[0].registerAddress.errorcode = 0;
-    tasks[0].registerAddress.cs = 8;
-    tasks[0].registerAddress.rflags = 663;
-    tasks[0].pid = 0;
-    p = &tasks[0];
-    tHead = p;
-    tHead->before = p;
-    tHead->next = p;
-    tasksNum = 1;
-
-    create_thread("111111", THREAD, &test_print1);
-    create_thread("2222222", THREAD, &test_print2);
-    create_thread("33333333333", THREAD, &test_print3);
-}
-
-void create_thread(char *name, enum task_type type, uint64_t functionAddress)
-{
-    // static struct TrapFrame tempFrame = {0};
-    //  static struct task_list tempTask = {0};
-
-    // tempTask.pid = p->pid + 1;
-
-    // for (int i = 0; i < 64; i++)
-    // {
-    //     tempTask.name[i] = name[i];
-    // }
-
-    // //双链表来管理任务
-    // tempTask.type = type;
-    // tempTask.before = p;
-    // tempTask.next = tHead;
-    // p->next = &tempTask;
-    // tHead->before = &tempTask;
-    // p = p->next;
-
-    // // p.pid = p.before.pid + 1;
-    // tempTask.status = TASK_DIED;
-    // //tempTask.registerAddress = tempRegister;
-    // tempTask.registerAddress.rip = functionAddress;
-    // tempTask.registerAddress.errorcode = 0;
-    // tempTask.registerAddress.cs = 8;
-    // tempTask.registerAddress.rflags = 663;
-    // tempTask.registerAddress.rsp = 0xffff800000000000 + 0x400000 - (tempTask.pid * 0x1000);
-
-    for (int i = 0; i < tasksNum; i++)
-    {
-        if (tasks[i].status == TASK_DIED)
-        {
-            p = &tasks[i];
-            set_task_status(name, p, functionAddress, type);
-            p->pid = p->before->pid + 1;
-            return;
-        }
-    }
-    tasksNum += 1;
-    //p = &tasks[tasksNum];
-    set_task_status(name, &tasks[tasksNum-1], functionAddress, type);
-    link_task(&tasks[tasksNum-1]);
-    p->pid = p->before->pid + 1;
-
-    registerList[p->pid].rip = functionAddress;
-    registerList[p->pid].errorcode = 0;
-    registerList[p->pid].rflags = 663;
-    registerList[p->pid].cs = 8;
-    registerList[p->pid].rsp = 0xffff800000000000 + 0x400000 - (p->pid * 0x1000);
-}
-
-void set_task_status(char *name, struct task_list *p, uint64_t functionAddress, enum task_type type)
-{
-    for (int i = 0; i < 64; i++)
-    {
-        p->name[i] = name[i];
-    }
-    p->status = TASK_WAITTING;
-    p->registerAddress.rip = functionAddress;
-    p->registerAddress.errorcode = 0;
-    p->registerAddress.cs = 8;
-    p->registerAddress.rflags = 663;
-    p->registerAddress.rsp = 0xffff800000000000 + 0x400000 - (p->pid * 0x1000);
-
-    
-
-}
-
-uint64_t link_task(struct task_list *tempTask)
-{
-    p->next = tempTask;
-    tempTask->before = p;
-    p = p->next;
-    p->next = tHead;
-    tHead->before = p;
-}
-
-void save_registers(struct TrapFrame *curThread, struct TrapFrame *tf)
-{
-    curThread->ss = tf->ss;
-    curThread->rsp = tf->rsp;
-    curThread->rflags = tf->rflags;
-    curThread->cs = tf->cs;
-    curThread->rip = tf->rip;
-    curThread->errorcode = tf->errorcode;
-    curThread->trapno = tf->trapno;
-    curThread->rax = tf->rax;
-    curThread->rbx = tf->rbx;
-    curThread->rcx = tf->rcx;
-    curThread->rdx = tf->rdx;
-    curThread->rsi = tf->rsi;
-    curThread->rdi = tf->rdi;
-    curThread->rbp = tf->rbp;
-    curThread->r8 = tf->r8;
-    curThread->r9 = tf->r9;
-    curThread->r10 = tf->r10;
-    curThread->r11 = tf->r11;
-    curThread->r12 = tf->r12;
-    curThread->r13 = tf->r13;
-    curThread->r14 = tf->r14;
-    curThread->r15 = tf->r15;
-}
\ No newline at end of file
diff --git a/kernel/aarch/arm/init.c b/kernel/aarch/arm/init.c
deleted file mode 100644
index a8dd798..0000000
--- a/kernel/aarch/arm/init.c
+++ /dev/null
@@ -1,18 +0,0 @@
-#include "arm/uart.h"
-#include "arm/mbox.h"
-
-void init_all(){
-   uart_init();
-
-    mbox[0] = 8*4;                  // length of the message
-    mbox[1] = MBOX_REQUEST;         // this is a request message
-    
-    mbox[2] = MBOX_TAG_GETSERIAL;   // get serial number command
-    mbox[3] = 8;                    // buffer size
-    mbox[4] = 8;
-    mbox[5] = 0;                    // clear output buffer
-    mbox[6] = 0;
-
-    mbox[7] = MBOX_TAG_LAST; 
-
-}
\ No newline at end of file
diff --git a/kernel/aarch/arm/mbox.c b/kernel/aarch/arm/mbox.c
deleted file mode 100644
index 908f448..0000000
--- a/kernel/aarch/arm/mbox.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2018 bzt (bztsrc@github)
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "arm/peripherals/gpio.h"
-
-/* mailbox message buffer */
-volatile unsigned int  __attribute__((aligned(16))) mbox[36];
-
-#define VIDEOCORE_MBOX  (MMIO_BASE+0x0000B880)
-#define MBOX_READ       ((volatile unsigned int*)(VIDEOCORE_MBOX+0x0))
-#define MBOX_POLL       ((volatile unsigned int*)(VIDEOCORE_MBOX+0x10))
-#define MBOX_SENDER     ((volatile unsigned int*)(VIDEOCORE_MBOX+0x14))
-#define MBOX_STATUS     ((volatile unsigned int*)(VIDEOCORE_MBOX+0x18))
-#define MBOX_CONFIG     ((volatile unsigned int*)(VIDEOCORE_MBOX+0x1C))
-#define MBOX_WRITE      ((volatile unsigned int*)(VIDEOCORE_MBOX+0x20))
-#define MBOX_RESPONSE   0x80000000
-#define MBOX_FULL       0x80000000
-#define MBOX_EMPTY      0x40000000
-
-/**
- * Make a mailbox call. Returns 0 on failure, non-zero on success
- */
-int mbox_call(unsigned char ch)
-{
-    unsigned int r = (((unsigned int)((unsigned long)&mbox)&~0xF) | (ch&0xF));
-    /* wait until we can write to the mailbox */
-    do{asm volatile("nop");}while(*MBOX_STATUS & MBOX_FULL);
-    /* write the address of our message to the mailbox with channel identifier */
-    *MBOX_WRITE = r;
-    /* now wait for the response */
-    while(1) {
-        /* is there a response? */
-        do{asm volatile("nop");}while(*MBOX_STATUS & MBOX_EMPTY);
-        /* is it a response to our message? */
-        if(r == *MBOX_READ)
-            /* is it a valid successful response? */
-            return mbox[1]==MBOX_RESPONSE;
-    }
-    return 0;
-}
diff --git a/kernel/aarch/arm/mm.S b/kernel/aarch/arm/mm.S
deleted file mode 100644
index 1bd32ff..0000000
--- a/kernel/aarch/arm/mm.S
+++ /dev/null
@@ -1,6 +0,0 @@
-.globl memzero
-memzero:
-	str xzr, [x0], #8
-	subs x1, x1, #8
-	b.gt memzero
-	ret
diff --git a/kernel/aarch/arm/put.c b/kernel/aarch/arm/put.c
deleted file mode 100644
index bfde0cb..0000000
--- a/kernel/aarch/arm/put.c
+++ /dev/null
@@ -1,5 +0,0 @@
-#include "arm/uart.h"
-
-void puts(char * str){
-    uart_puts(str);
-}
\ No newline at end of file
diff --git a/kernel/aarch/arm/uart.c b/kernel/aarch/arm/uart.c
deleted file mode 100644
index de8eb4e..0000000
--- a/kernel/aarch/arm/uart.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2018 bzt (bztsrc@github)
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- */
-
-#include "arm/peripherals/gpio.h"
-#include "arm/mbox.h"
-
-/* PL011 UART registers */
-#define UART0_DR        ((volatile unsigned int*)(MMIO_BASE+0x00201000))
-#define UART0_FR        ((volatile unsigned int*)(MMIO_BASE+0x00201018))
-#define UART0_IBRD      ((volatile unsigned int*)(MMIO_BASE+0x00201024))
-#define UART0_FBRD      ((volatile unsigned int*)(MMIO_BASE+0x00201028))
-#define UART0_LCRH      ((volatile unsigned int*)(MMIO_BASE+0x0020102C))
-#define UART0_CR        ((volatile unsigned int*)(MMIO_BASE+0x00201030))
-#define UART0_IMSC      ((volatile unsigned int*)(MMIO_BASE+0x00201038))
-#define UART0_ICR       ((volatile unsigned int*)(MMIO_BASE+0x00201044))
-
-/**
- * Set baud rate and characteristics (115200 8N1) and map to GPIO
- */
-void uart_init()
-{
-    register unsigned int r;
-
-    /* initialize UART */
-    *UART0_CR = 0;         // turn off UART0
-
-    /* set up clock for consistent divisor values */
-    mbox[0] = 9*4;
-    mbox[1] = MBOX_REQUEST;
-    mbox[2] = MBOX_TAG_SETCLKRATE; // set clock rate
-    mbox[3] = 12;
-    mbox[4] = 8;
-    mbox[5] = 2;           // UART clock
-    mbox[6] = 4000000;     // 4Mhz
-    mbox[7] = 0;           // clear turbo
-    mbox[8] = MBOX_TAG_LAST;
-    mbox_call(MBOX_CH_PROP);
-
-    /* map UART0 to GPIO pins */
-    r=*GPFSEL1;
-    r&=~((7<<12)|(7<<15)); // gpio14, gpio15
-    r|=(4<<12)|(4<<15);    // alt0
-    *GPFSEL1 = r;
-    *GPPUD = 0;            // enable pins 14 and 15
-    r=150; while(r--) { asm volatile("nop"); }
-    *GPPUDCLK0 = (1<<14)|(1<<15);
-    r=150; while(r--) { asm volatile("nop"); }
-    *GPPUDCLK0 = 0;        // flush GPIO setup
-
-    *UART0_ICR = 0x7FF;    // clear interrupts
-    *UART0_IBRD = 2;       // 115200 baud
-    *UART0_FBRD = 0xB;
-    *UART0_LCRH = 0x7<<4;  // 8n1, enable FIFOs
-    *UART0_CR = 0x301;     // enable Tx, Rx, UART
-}
-
-/**
- * Send a character
- */
-void uart_send(unsigned int c) {
-    /* wait until we can send */
-    do{asm volatile("nop");}while(*UART0_FR&0x20);
-    /* write the character to the buffer */
-    *UART0_DR=c;
-}
-
-/**
- * Receive a character
- */
-char uart_getc() {
-    char r;
-    /* wait until something is in the buffer */
-    do{asm volatile("nop");}while(*UART0_FR&0x10);
-    /* read it and return */
-    r=(char)(*UART0_DR);
-    /* convert carrige return to newline */
-    return r=='\r'?'\n':r;
-}
-
-/**
- * Display a string
- */
-void uart_puts(char *s) {
-    while(*s) {
-        /* convert newline to carrige return + newline */
-        if(*s=='\n')
-            uart_send('\r');
-        uart_send(*s++);
-    }
-}
-
-/**
- * Display a binary value in hexadecimal
- */
-void uart_hex(unsigned int d) {
-    unsigned int n;
-    int c;
-    for(c=28;c>=0;c-=4) {
-        // get highest tetrad
-        n=(d>>c)&0xF;
-        // 0-9 => '0'-'9', 10-15 => 'A'-'F'
-        n+=n>9?0x37:0x30;
-        uart_send(n);
-    }
-}
diff --git a/kernel/aarch/arm/utils.S b/kernel/aarch/arm/utils.S
deleted file mode 100644
index c35527a..0000000
--- a/kernel/aarch/arm/utils.S
+++ /dev/null
@@ -1,15 +0,0 @@
-.globl put32
-put32:
-	str w1,[x0]
-	ret
-
-.globl get32
-get32:
-	ldr w0,[x0]
-	ret
-
-.globl delay
-delay:
-	subs x0, x0, #1
-	bne delay
-	ret
diff --git a/kernel/aarch/amd64/init.c b/kernel/arch/amd64/init.c
similarity index 72%
rename from kernel/aarch/amd64/init.c
rename to kernel/arch/amd64/init.c
index 06deefc..7ef8eef 100644
--- a/kernel/aarch/amd64/init.c
+++ b/kernel/arch/amd64/init.c
@@ -4,14 +4,15 @@
 #include "printk.h"
 #include "amd64/trap.h"
 #include "amd64/init.h"
-#include "amd64/thread.h"
+#include "task.h"
 
 //初始化所有服务
 void init_all()
 {
-    init_thread();
+    disable_interruption();
     init_print();
     init_idt();
-
+    init_task();
     // init_memory();
+    enable_interruption();
 }
\ No newline at end of file
diff --git a/kernel/arch/amd64/interruption.c b/kernel/arch/amd64/interruption.c
new file mode 100644
index 0000000..a9ffbcb
--- /dev/null
+++ b/kernel/arch/amd64/interruption.c
@@ -0,0 +1,11 @@
+#include "interruption.h"
+
+void enable_interruption(void)
+{
+    __asm__ __volatile__("sti");
+}
+
+void disable_interruption(void)
+{
+    __asm__ __volatile__("cli");
+}
\ No newline at end of file
diff --git a/kernel/aarch/amd64/makefile b/kernel/arch/amd64/makefile
similarity index 100%
rename from kernel/aarch/amd64/makefile
rename to kernel/arch/amd64/makefile
diff --git a/kernel/aarch/amd64/mapping.c b/kernel/arch/amd64/mapping.c
similarity index 77%
rename from kernel/aarch/amd64/mapping.c
rename to kernel/arch/amd64/mapping.c
index af14433..0242487 100644
--- a/kernel/aarch/amd64/mapping.c
+++ b/kernel/arch/amd64/mapping.c
@@ -4,7 +4,7 @@
  * Date: 2021-12-30 01:02:11
  * LastEditTime: 2022-01-02 03:39:32
  * LastEditors: Benji Xu
- * FilePath: /dolphin2/kernel/aarch/amd64/mapping.c
+ * FilePath: /dolphin2/kernel/arch/amd64/mapping.c
  * Description: this .c file is going to implement the malloc
  * 描述: 这个点C文件是为了实现malloc
  */
@@ -18,9 +18,9 @@
 #define BASE_VIRTUAL_ADDRESS 0xffff800000000000
 
 struct page_infor pageInfor = {0, 0, 0};
-struct page_dir_manage cr3Infor;
-struct page_dir_manage firstDirInfor;
-struct page_dir_manage secondDirInfor;
+struct page_dir_manage dir0;
+struct page_dir_manage dir1;
+struct page_dir_manage dir2;
 uint64_t *ecx = 0x90000;
 
 /**
@@ -44,23 +44,23 @@ void init_malloc(uint64_t cr3, uint64_t firstDir, uint64_t secondDir, enum proce
 {
     if (program == KERNEL)
     {
-        cr3Infor.dirState = IN_USE;
-        cr3Infor.address = 0x70000;
-        cr3Infor.usedAmount = 1;
-        cr3Infor.attri = CR3;
-        cr3Infor.next = 0;
+        dir0.dirState = IN_USE;
+        dir0.address = 0x70000;
+        dir0.usedAmount = 1;
+        dir0.attri = CR3;
+        dir0.next = 0;
 
-        firstDirInfor.dirState = IN_USE;
-        firstDirInfor.address = 0x73000;
-        firstDirInfor.usedAmount = 1;
-        firstDirInfor.attri = FRIST_DIR;
-        firstDirInfor.next = 0;
+        dir1.dirState = IN_USE;
+        dir1.address = 0x73000;
+        dir1.usedAmount = 1;
+        dir1.attri = FRIST_DIR;
+        dir1.next = 0;
 
-        secondDirInfor.dirState = IN_USE;
-        secondDirInfor.address = 0x74000;
-        secondDirInfor.usedAmount = *ecx;
-        secondDirInfor.attri = SECOND_DIR;
-        secondDirInfor.next = pageDirAddress + 0x1000;
+        dir2.dirState = IN_USE;
+        dir2.address = 0x74000;
+        dir2.usedAmount = *ecx;
+        dir2.attri = SECOND_DIR;
+        dir2.next = pageDirAddress + 0x1000;
 
         pageInfor.dirAddress = 0x74000;
         pageInfor.pPhysicalAdrress = pageHead;
@@ -82,11 +82,10 @@ void init_malloc(uint64_t cr3, uint64_t firstDir, uint64_t secondDir, enum proce
  */
 void *malloc_page(uint64_t pageAmount)
 {
-
     find_physical_address();
     for (uint32_t i = 0; i < pageAmount; i++)
     {
-        secondDirInfor.usedAmount = mapping(secondDirInfor.address, secondDirInfor.usedAmount, pageInfor.pPhysicalAdrress, SECOND_DIR);
+        dir2.usedAmount = mapping(dir2.address, dir2.usedAmount, pageInfor.pPhysicalAdrress, SECOND_DIR);
         struct page *p = pageInfor.pPhysicalAdrress;
         if (p->next == NULL)
         {
@@ -94,12 +93,12 @@ void *malloc_page(uint64_t pageAmount)
             ASSERT(1 < 0, "malloc_page(): run out the physical memory");
         }
         pageInfor.pPhysicalAdrress = pageInfor.pPhysicalAdrress->next;
-        if (secondDirInfor.usedAmount == 0)
+        if (dir2.usedAmount == 0)
         {
-            secondDirInfor.address = secondDirInfor.next;
-            secondDirInfor.next += 0x1000;
-            firstDirInfor.usedAmount = mapping(firstDirInfor.address, firstDirInfor.usedAmount, secondDirInfor.address, FRIST_DIR);
-            if (firstDirInfor.usedAmount == 0)
+            dir2.address = dir2.next;
+            dir2.next += 0x1000;
+            dir1.usedAmount = mapping(dir1.address, dir1.usedAmount, dir2.address, FRIST_DIR);
+            if (dir1.usedAmount == 0)
             {
                 printk("run out of the virtual memory!!!");
                 return NULL;
@@ -108,6 +107,7 @@ void *malloc_page(uint64_t pageAmount)
     }
     pageInfor.virtualAddress += pageAmount * 2 * 1024 * 1024;
     // pageInfor.virtualAddress += 0x40000000;
+
     /* test code */
     uint64_t *test = 0xffff8000006ffff0;
     *test = 12;
@@ -122,7 +122,7 @@ void *malloc_page(uint64_t pageAmount)
  */
 void *free_page(uint64_t pageAmount)
 {
-    uint64_t *cr3 = cr3Infor.address;
+    uint64_t *cr3 = dir0.address;
     uint32_t index = pageInfor.virtualAddress >> 39;
     index = index & 0x1ff;
     uint64_t *firstDirArray = (cr3[index] >> 12) << 12;
@@ -137,7 +137,7 @@ void *free_page(uint64_t pageAmount)
         secondDirArray[index - 1] = 0;
         if (index - 1 == 0)
         {
-            secondDirInfor.next -= 0x1000;
+            dir2.next -= 0x1000;
         }
         pageTail = pageTail->next;
         pageTail->next = NULL;
@@ -151,10 +151,10 @@ uint64_t find_physical_address()
     printk("find: %x\n", pageInfor.pPhysicalAdrress);
 }
 
-uint64_t mapping(uint64_t dirAddress, uint64_t index, uint64_t Address, enum attributes attris)
+uint64_t mapping(uint64_t dirAddress, uint64_t index, uint64_t address, enum attributes attris)
 {
     uint64_t *dirArray = dirAddress;
-    dirArray[index] = Address;
+    dirArray[index] = address;
     if (attris == SECOND_DIR)
     {
         dirArray[index] += 0x83;
diff --git a/kernel/aarch/amd64/memory.c b/kernel/arch/amd64/memory.c
similarity index 99%
rename from kernel/aarch/amd64/memory.c
rename to kernel/arch/amd64/memory.c
index 74cd2e9..f7c905a 100644
--- a/kernel/aarch/amd64/memory.c
+++ b/kernel/arch/amd64/memory.c
@@ -14,7 +14,7 @@
 #include "stddef.h"
 #include "amd64/mapping.h"
 
-uint64_t pageSize = 0x200000;
+uint64_t pageSize = 0x200000; //2mb
 
 static struct free_mem_region FreeMemRegion[50];
 
diff --git a/kernel/aarch/amd64/put.c b/kernel/arch/amd64/put.c
similarity index 97%
rename from kernel/aarch/amd64/put.c
rename to kernel/arch/amd64/put.c
index 89c157c..ffcee7a 100644
--- a/kernel/aarch/amd64/put.c
+++ b/kernel/arch/amd64/put.c
@@ -2,7 +2,7 @@
 
 DisPlay_Char chs;
 
-/* 一个接一个现实字符 */
+/* 一个接一个显示字符 */
 void print_char(uint8_t ch)
 {
 	chs.vram[chs.cursor_pos * 2] = ch;
diff --git a/kernel/arch/amd64/register.c b/kernel/arch/amd64/register.c
new file mode 100644
index 0000000..f78e8e5
--- /dev/null
+++ b/kernel/arch/amd64/register.c
@@ -0,0 +1,37 @@
+#include "amd64/register.h"
+#include "stdint.h"
+
+void set_task_register(int pid, uint64_t functionAddress)
+{
+    registerList[pid].rip = functionAddress;
+    registerList[pid].errorcode = 0;
+    registerList[pid].rflags = 663;
+    registerList[pid].cs = 8;
+    registerList[pid].rsp = 0xffff800000000000 + 0x400000 - (pid * 0x1000);
+}
+
+void save_registers(struct TrapFrame *curTask, struct TrapFrame *tf)
+{
+    curTask->ss = tf->ss;
+    curTask->rsp = tf->rsp;
+    curTask->rflags = tf->rflags;
+    curTask->cs = tf->cs;
+    curTask->rip = tf->rip;
+    curTask->errorcode = tf->errorcode;
+    curTask->trapno = tf->trapno;
+    curTask->rax = tf->rax;
+    curTask->rbx = tf->rbx;
+    curTask->rcx = tf->rcx;
+    curTask->rdx = tf->rdx;
+    curTask->rsi = tf->rsi;
+    curTask->rdi = tf->rdi;
+    curTask->rbp = tf->rbp;
+    curTask->r8 = tf->r8;
+    curTask->r9 = tf->r9;
+    curTask->r10 = tf->r10;
+    curTask->r11 = tf->r11;
+    curTask->r12 = tf->r12;
+    curTask->r13 = tf->r13;
+    curTask->r14 = tf->r14;
+    curTask->r15 = tf->r15;
+}
\ No newline at end of file
diff --git a/kernel/aarch/amd64/start.asm b/kernel/arch/amd64/start.asm
similarity index 91%
rename from kernel/aarch/amd64/start.asm
rename to kernel/arch/amd64/start.asm
index a9716ea..b551ab5 100644
--- a/kernel/aarch/amd64/start.asm
+++ b/kernel/arch/amd64/start.asm
@@ -29,7 +29,7 @@ Tss:
 
 TssLen: equ $-Tss
 
-section .text
+section .text.boot
 extern kernel_init
 global start
 
@@ -100,8 +100,7 @@ KernelEntry:
     
     call kernel_init
     
-    
-
+section .text
 End:
     hlt
     jmp End
diff --git a/kernel/aarch/amd64/trap.c b/kernel/arch/amd64/trap.c
similarity index 95%
rename from kernel/aarch/amd64/trap.c
rename to kernel/arch/amd64/trap.c
index 98ba03f..ac5247d 100644
--- a/kernel/aarch/amd64/trap.c
+++ b/kernel/arch/amd64/trap.c
@@ -2,7 +2,8 @@
 #include "printk.h"
 #include "debug.h"
 #include "amd64/init.h"
-#include "amd64/thread.h"
+#include "task.h"
+#include "amd64/register.h"
 
 static struct IdtPtr idt_pointer;
 static struct IdtEntry vectors[256];
diff --git a/kernel/aarch/amd64/trapa.asm b/kernel/arch/amd64/trapa.asm
similarity index 92%
rename from kernel/aarch/amd64/trapa.asm
rename to kernel/arch/amd64/trapa.asm
index ce9e3c9..4214f6e 100644
--- a/kernel/aarch/amd64/trapa.asm
+++ b/kernel/arch/amd64/trapa.asm
@@ -1,4 +1,3 @@
-
 section .text
 extern handler
 global vector0
diff --git a/kernel/arch/arm/handler.c b/kernel/arch/arm/handler.c
new file mode 100644
index 0000000..c337e32
--- /dev/null
+++ b/kernel/arch/arm/handler.c
@@ -0,0 +1,89 @@
+#include "stdint.h"
+#include "printk.h"
+#include "task.h"
+#include "arm/lib.h"
+#include "arm/irq.h"
+#include "arm/uart.h"
+#include "arm/register.h"
+
+void enable_timer(void);
+uint32_t read_timer_status(void);
+void set_timer_interval(uint32_t value);
+uint32_t read_timer_freq(void);
+void set_elr_el(uint64_t elr);
+void disable_timer(void);
+void irq_return(uint64_t sp);
+void set_spsr_el(uint64_t spsr_el);
+
+static uint32_t timer_interval = 0;
+static uint64_t ticks = 0;
+
+void init_timer(void)
+{
+    timer_interval = read_timer_freq() / 100;
+    enable_timer();
+    out_word(CNTP_EL0, (1 << 1));
+    // r1.sp = 0x80000 - 0x1000;
+    // r2.sp = 0x80000 - 0x2000;
+    // r1.elr_el1 = &test_print1;
+    // r2.elr_el1 = &test_print2;
+}
+
+static void timer_interrupt_handler(uint64_t esr, uint64_t elr, uint64_t sp, uint64_t spsr, uint64_t ttbr0_el1, uint64_t ttbr1_el1)
+{
+    uint32_t status = read_timer_status();
+    disable_timer();
+    if (status & (1 << 2))
+    {
+        while (p->status != TASK_RUNNING)
+        {
+            p = p->next;
+        }
+
+        p->status = TASK_WAITTING;
+        save_registers(&registerList[p->pid], sp, elr, spsr, sp + (32 * 8));
+        //switch_el();
+        p = p->next;
+        set_timer_interval(timer_interval);
+        set_elr_el(registerList[p->pid].elr_el1);
+        //set_spsr_el(r2.spsr_el1);
+        p->status = TASK_RUNNING;
+        irq_return(&registerList[p->pid]);
+
+    }
+}
+
+void handler(uint64_t numid, uint64_t esr, uint64_t elr, uint64_t sp, uint64_t spsr, uint64_t ttbr0_el1, uint64_t ttbr1_el1)
+{
+    uint32_t irq;
+
+    switch (numid)
+    {
+    case 1:
+        printk("sync error at %x: %x\r\n", elr, esr);
+        while (1)
+        {
+        }
+
+    case 2:
+        irq = in_word(CNTP_STATUS_EL0);
+        if (irq & (1 << 1))
+        {
+            timer_interrupt_handler(esr, elr, sp, spsr, ttbr0_el1, ttbr1_el1);
+        }
+        else
+        {
+            printk("unknown irq \r\n");
+            while (1)
+            {
+            }
+        }
+        break;
+
+    default:
+        printk("unknown exception\r\n");
+        while (1)
+        {
+        }
+    }
+}
\ No newline at end of file
diff --git a/kernel/arch/arm/handlera.S b/kernel/arch/arm/handlera.S
new file mode 100644
index 0000000..a20d990
--- /dev/null
+++ b/kernel/arch/arm/handlera.S
@@ -0,0 +1,279 @@
+.section .text
+.global vector_table
+.global enable_timer
+.global read_timer_freq
+.global read_timer_status
+.global set_timer_interval
+.global enable_irq
+.global set_elr_el
+.global disable_timer
+.global irq_return
+.global set_spsr_el
+.global switch_el
+.global load_ttbr0
+
+.balign 0x800
+vector_table:
+current_el_sp0_sync:
+    b error
+
+.balign 0x80
+current_el_sp0_irq:
+    b error
+
+.balign 0x80
+current_el_sp0_fiq:
+    b error
+
+.balign 0x80
+current_el_sp0_serror:
+    b error
+
+.balign 0x80
+current_el_spn_sync:
+    b sync_handler
+
+.balign 0x80
+current_el_spn_irq:
+    b irq_handler
+
+.balign 0x80
+current_el_spn_fiq:
+    b error
+
+.balign 0x80
+current_el_spn_serror:
+    b error
+
+.balign 0x80
+lower_el_aarch64_sync:
+    b error
+
+.balign 0x80
+lower_el_aarch64_irq:
+    b error
+
+.balign 0x80
+lower_el_aarch64_fiq:
+    b error
+
+.balign 0x80
+lower_el_aarch64_serror:
+    b error
+
+.balign 0x80
+lower_el_aarch32_sync:
+    b error
+
+.balign 0x80
+lower_el_aarch32_irq:
+    b error
+
+.balign 0x80
+lower_el_aarch32_fiq:
+    b error
+
+.balign 0x80
+lower_el_aarch32_serror:
+    b error
+
+
+sync_handler:
+    sub sp, sp, #(32 * 8)
+    stp x0, x1, [sp]
+    stp x2, x3, [sp, #(16 * 1)]
+    stp x4, x5, [sp, #(16 * 2)]
+    stp	x6, x7, [sp, #(16 * 3)]
+	stp	x8, x9, [sp, #(16 * 4)]
+	stp	x10, x11, [sp, #(16 * 5)]
+	stp	x12, x13, [sp, #(16 * 6)]
+	stp	x14, x15, [sp, #(16 * 7)]
+	stp	x16, x17, [sp, #(16 * 8)]
+	stp	x18, x19, [sp, #(16 * 9)]
+	stp	x20, x21, [sp, #(16 * 10)]
+	stp	x22, x23, [sp, #(16 * 11)]
+	stp	x24, x25, [sp, #(16 * 12)]
+	stp	x26, x27, [sp, #(16 * 13)]
+	stp	x28, x29, [sp, #(16 * 14)]
+    str x30, [sp, #(16 * 15)]
+
+    mov x0, #1
+    mrs x1, esr_el1
+    mrs x2, elr_el1
+    bl handler
+
+    ldp x0, x1, [sp]
+    ldp x2, x3, [sp, #(16 * 1)]
+    ldp x4, x5, [sp, #(16 * 2)]
+    ldp	x6, x7, [sp, #(16 * 3)]
+	ldp	x8, x9, [sp, #(16 * 4)]
+	ldp	x10, x11, [sp, #(16 * 5)]
+	ldp	x12, x13, [sp, #(16 * 6)]
+	ldp	x14, x15, [sp, #(16 * 7)]
+	ldp	x16, x17, [sp, #(16 * 8)]
+	ldp	x18, x19, [sp, #(16 * 9)]
+	ldp	x20, x21, [sp, #(16 * 10)]
+	ldp	x22, x23, [sp, #(16 * 11)]
+	ldp	x24, x25, [sp, #(16 * 12)]
+	ldp	x26, x27, [sp, #(16 * 13)]
+	ldp	x28, x29, [sp, #(16 * 14)]
+    ldr x30, [sp, #(16 * 15)]
+
+    add sp, sp, #(32 * 8)
+    eret
+
+irq_handler:
+    sub sp, sp, #(32 * 8)
+    stp x0, x1, [sp]
+    stp x2, x3, [sp, #(16 * 1)]
+    stp x4, x5, [sp, #(16 * 2)]
+    stp	x6, x7, [sp, #(16 * 3)]
+	stp	x8, x9, [sp, #(16 * 4)]
+	stp	x10, x11, [sp, #(16 * 5)]
+	stp	x12, x13, [sp, #(16 * 6)]
+	stp	x14, x15, [sp, #(16 * 7)]
+	stp	x16, x17, [sp, #(16 * 8)]
+	stp	x18, x19, [sp, #(16 * 9)]
+	stp	x20, x21, [sp, #(16 * 10)]
+	stp	x22, x23, [sp, #(16 * 11)]
+	stp	x24, x25, [sp, #(16 * 12)]
+	stp	x26, x27, [sp, #(16 * 13)]
+	stp	x28, x29, [sp, #(16 * 14)]
+    str x30, [sp, #(16 * 15)]
+
+    mov x0, #2
+    mrs x1, esr_el1
+    mrs x2, elr_el1
+    mov x3, sp
+    mrs x4, spsr_el1
+    mrs x5, ttbr0_el1
+    mrs x6, ttbr1_el1
+    bl handler
+
+irq_return:
+    ldp x2, x3, [x0, #(16 * 1)]
+    ldp x4, x5, [x0, #(16 * 2)]
+    ldp	x6, x7, [x0, #(16 * 3)]
+	ldp	x8, x9, [x0, #(16 * 4)]
+	ldp	x10, x11, [x0, #(16 * 5)]
+	ldp	x12, x13, [x0, #(16 * 6)]
+	ldp	x14, x15, [x0, #(16 * 7)]
+	ldp	x16, x17, [x0, #(16 * 8)]
+	ldp	x18, x19, [x0, #(16 * 9)]
+	ldp	x20, x21, [x0, #(16 * 10)]
+	ldp	x22, x23, [x0, #(16 * 11)]
+	ldp	x24, x25, [x0, #(16 * 12)]
+	ldp	x26, x27, [x0, #(16 * 13)]
+	ldp	x28, x29, [x0, #(16 * 14)]
+    ldr x30, [x0, #(8 * 31)]
+    mov sp, x30
+    ldr x1, [x0, #(8 * 1)]
+    mov x30, #1
+    msr CNTP_CTL_EL0, x30  //enable timer
+    ldr x30, [x0, #(8 * 30)]
+    
+    ldr x0, [x0]    
+    
+    eret
+
+error:
+    sub sp, sp, #(32 * 8)
+    mrs x0, esr_el1
+    stp x0, x1, [sp]
+    stp x2, x3, [sp, #(16 * 1)]
+    stp x4, x5, [sp, #(16 * 2)]
+    stp	x6, x7, [sp, #(16 * 3)]
+	stp	x8, x9, [sp, #(16 * 4)]
+	stp	x10, x11, [sp, #(16 * 5)]
+	stp	x12, x13, [sp, #(16 * 6)]
+	stp	x14, x15, [sp, #(16 * 7)]
+	stp	x16, x17, [sp, #(16 * 8)]
+	stp	x18, x19, [sp, #(16 * 9)]
+	stp	x20, x21, [sp, #(16 * 10)]
+	stp	x22, x23, [sp, #(16 * 11)]
+	stp	x24, x25, [sp, #(16 * 12)]
+	stp	x26, x27, [sp, #(16 * 13)]
+	stp	x28, x29, [sp, #(16 * 14)]
+    str x30, [sp, #(16 * 15)]
+
+    mov x0, #0
+    bl handler
+
+    ldp x0, x1, [sp]
+    ldp x2, x3, [sp, #(16 * 1)]
+    ldp x4, x5, [sp, #(16 * 2)]
+    ldp	x6, x7, [sp, #(16 * 3)]
+	ldp	x8, x9, [sp, #(16 * 4)]
+	ldp	x10, x11, [sp, #(16 * 5)]
+	ldp	x12, x13, [sp, #(16 * 6)]
+	ldp	x14, x15, [sp, #(16 * 7)]
+	ldp	x16, x17, [sp, #(16 * 8)]
+	ldp	x18, x19, [sp, #(16 * 9)]
+	ldp	x20, x21, [sp, #(16 * 10)]
+	ldp	x22, x23, [sp, #(16 * 11)]
+	ldp	x24, x25, [sp, #(16 * 12)]
+	ldp	x26, x27, [sp, #(16 * 13)]
+	ldp	x28, x29, [sp, #(16 * 14)]
+    ldr x30, [sp, #(16 * 15)]
+
+    add sp, sp, #(32 * 8)
+    eret
+    
+read_timer_freq:
+    mrs x0, CNTFRQ_EL0
+    ret
+
+set_timer_interval:
+    msr CNTP_TVAL_El0, x0
+    ret
+
+enable_timer:
+    stp x29, x30, [sp, #-16]!
+
+    bl read_timer_freq
+    mov x1, #100
+    udiv x0, x0, x1
+    bl set_timer_interval
+
+    mov x0, #1
+    msr CNTP_CTL_EL0, x0
+
+    ldp x29, x30, [sp], #16
+    ret
+
+read_timer_status:
+    mrs x0, CNTP_CTL_EL0
+    ret
+
+enable_irq:
+    msr daifclr, #2
+    ret
+
+set_elr_el:
+    msr elr_el1, x0
+    ret
+
+set_spsr_el:
+    msr spsr_el1, x0
+    ret
+
+disable_timer:
+    mov x0, #0
+    msr CNTP_CTL_EL0, x0
+    ret
+
+switch_el:
+    mov x1, #960
+    msr spsr_el1, x1
+    msr elr_el1, x0
+    ldr x0, =69632
+    msr sp_el0, x0
+    eret
+
+load_ttbr0:
+    tlbi vmalle1is
+    dsb ish
+    isb
+    ret
+
+
diff --git a/kernel/arch/arm/init.c b/kernel/arch/arm/init.c
new file mode 100644
index 0000000..88f23f5
--- /dev/null
+++ b/kernel/arch/arm/init.c
@@ -0,0 +1,62 @@
+#include "arm/uart.h"
+#include "arm/lib.h"
+#include "arm/memory.h"
+#include "printk.h"
+#include "stdint.h"
+#include "task.h"
+#include "arm/handler.h"
+
+int test11()
+{
+    uint64_t x = 0x8888888;
+    return 0;
+}
+
+void init_all()
+{
+    init_uart();
+    printk("test!!!!!");
+
+    printk("We current at level: %d\n", (uint64_t)get_el());
+
+    init_memory();
+
+    uint64_t *page = 0x88000;
+    *page = *page | 1 << 6;
+
+    page = 0x87000;
+    *page = ((*page >> 10) << 10) + 0x447;
+
+    page = 0x86000;
+    *page = ((*page >> 10) << 10) + 0x447;
+
+    load_ttbr0();
+
+    uint64_t *t = &test11;
+    uint64_t tt = t;
+    tt = (tt << 16) >> 16;
+    switch_el(tt);
+
+    uint64_t *p = 0x80000;
+    *p = 250;
+    printk("We current at level: %d\n", (uint64_t)get_el());
+
+    printk("teste2 %d\n", *p);
+    while (1)
+    {
+        /* code */
+    }
+
+    init_task();
+    init_timer();
+    enable_irq();
+    while (1)
+    {
+        for (int i = 0; i < 100; i++)
+        {
+            /* code */
+        }
+        printk(" T000 ");
+        /* code */
+    }
+}
diff --git a/kernel/arch/arm/lib.S b/kernel/arch/arm/lib.S
new file mode 100644
index 0000000..76c422d
--- /dev/null
+++ b/kernel/arch/arm/lib.S
@@ -0,0 +1,89 @@
+.global delay
+.global out_word
+.global in_word
+.global memset
+.global memcpy
+.global memmove
+.global memcmp
+.global get_el
+
+get_el:
+    mrs x0, currentel
+    lsr x0, x0, #2
+    ret
+
+delay:
+    subs x0, x0, #1
+    bne delay
+    ret
+
+out_word:
+    str w1, [x0]
+    ret
+
+in_word:
+    ldr w0, [x0]
+    ret
+
+memset:
+    cmp x2, #0
+    beq memset_end
+
+set:
+    strb w1, [x0], #1
+    subs x2, x2, #1
+    bne set
+
+memset_end:
+    ret
+
+memcmp:
+    mov x3, x0
+    mov x0, #0
+
+compare:
+    cmp x2, #0
+    beq memcmp_end
+
+    ldrb w4, [x3], #1
+    ldrb w5, [x1], #1
+    sub x2, x2, #1
+    cmp w4, w5
+    beq compare
+
+    mov x0, #1
+
+memcmp_end:
+    ret
+
+memmove:
+memcpy:
+    cmp x2, #0
+    beq memcpy_end
+
+    mov x4, #1
+
+    cmp x1, x0
+    bhs copy
+    add x3, x1, x2
+    cmp x3, x0
+    bls copy
+
+overlap:
+    sub x3, x2, #1
+    add x0, x0, x3
+    add x1, x1, x3
+    neg x4, x4
+
+copy:
+    ldrb w3, [x1]
+    strb w3, [x0]
+    add x0, x0, x4
+    add x1, x1, x4
+
+    subs x2, x2, #1
+    bne copy
+
+memcpy_end:
+    ret
+    
\ No newline at end of file
diff --git a/kernel/aarch/arm/makefile b/kernel/arch/arm/makefile
similarity index 100%
rename from kernel/aarch/arm/makefile
rename to kernel/arch/arm/makefile
diff --git a/kernel/arch/arm/mapping.c b/kernel/arch/arm/mapping.c
new file mode 100644
index 0000000..f0f8ec8
--- /dev/null
+++ b/kernel/arch/arm/mapping.c
@@ -0,0 +1,135 @@
+#include "arm/memory.h"
+#include "arm/mapping.h"
+#include "printk.h"
+#include "debug.h"
+#include "stddef.h"
+#include "debug.h"
+
+struct page_infor pageInfor = {0, 0, 0};
+struct page_dir_manage dir0;
+struct page_dir_manage dir1;
+struct page_dir_manage dir2;
+
+void init_malloc(uint64_t ttbr1_el1, uint64_t directory1, uint64_t directory2, enum procedure_type program)
+{
+    if (program == KERNEL)
+    {
+        dir0.dirState = IN_USE;
+        dir0.address = 0x82000;
+        dir0.usedAmount = 1;
+        dir0.attri = DIR0;
+        dir0.next = 0; //只开启512gb虚拟内存空间
+
+        dir1.dirState = IN_USE;
+        dir1.address = 0x83000;
+        dir1.usedAmount = 1;
+        dir1.attri = DIR1;
+        dir1.next = 0;
+
+        dir2.dirState = IN_USE;
+        dir2.address = 0x200000;
+        dir2.usedAmount = 2;
+        dir2.attri = DIR2;
+        dir2.next = 0x200000 + 0x1000;
+
+        pageInfor.dirAddress = 0x200000;
+        pageInfor.pPhysicalAdrress = pageHead;
+        pageInfor.virtualAddress = 2 * 1024 * 1024 * 2 + KERNEL_BASE;
+    }
+    else
+    {
+    }
+}
+
+void malloc_page(uint64_t pageAmount)
+{
+    
+    for (uint32_t i = 0; i < pageAmount; i++)
+    {
+        dir2.usedAmount = mapping(dir2.address, dir2.usedAmount, pageInfor.pPhysicalAdrress, DIR2);
+        struct page *p = pageInfor.pPhysicalAdrress;
+        if (p->next == NULL)
+        {
+            printk("p_address: %x %d", p, i);
+            ASSERT(1 < 0, "malloc_page(): run out the physical memory");
+        }
+        pageInfor.pPhysicalAdrress = pageInfor.pPhysicalAdrress->next;
+        if (dir2.usedAmount == 0)
+        {
+            dir2.address = dir2.next;
+            dir2.next += 0x1000;
+            dir1.usedAmount = mapping(dir1.address, dir1.usedAmount, dir1.address, DIR1);
+            if (dir1.usedAmount == 0)
+            {
+                printk("run out of the virtual memory!!!");
+                return NULL;
+            }
+        }
+    }
+    pageInfor.virtualAddress += pageAmount * 2 * 1024 * 1024;
+    // pageInfor.virtualAddress += 0x40000000;
+
+    /* test code */
+
+}
+
+uint64_t find_physical_address()
+{
+    pageInfor.pPhysicalAdrress = pageHead;
+    printk("find: %x\n", pageInfor.pPhysicalAdrress);
+}
+
+uint64_t mapping(uint64_t dirAddress, uint64_t index, uint64_t address, enum attributes attris)
+{
+    uint64_t *dirArray = dirAddress;
+    dirArray[index] = address;
+    if (attris == DIR2)
+    {
+        dirArray[index] += 0x405;
+    }
+    else if (attris == DIR1)
+    {
+        dirArray[index] += 0x0;
+    }
+    if (index >= 511)
+    {
+        return 0;
+    }
+    else
+    {
+        return index + 1;
+    }
+}
+
+/**
+ * function: free_page
+ * @param [uint64_t] pageAccount : The amount of pages that you want to release.
+ * @return [void]
+ * description: release the page.
+ * 释放页。
+ */
+void free_page(uint64_t pageAmount)
+{
+    uint64_t *cr3 = dir0.address;
+    uint32_t index = pageInfor.virtualAddress >> 39;
+    index = index & 0x1ff;
+    uint64_t *firstDirArray = (cr3[index] >> 12) << 12;
+    uint64_t *secondDirArray;
+    for (uint32_t i = 0; i < pageAmount; i++)
+    {
+        index = pageInfor.virtualAddress >> 30;
+        index = index & 0x1ff;
+        uint64_t *secondDirArray = (firstDirArray[index] >> 12) << 12;
+        index = ((pageInfor.virtualAddress << 34) >> 34) / 0x200000;
+        pageTail->next = secondDirArray[index - 1];
+        secondDirArray[index - 1] = 0;
+        if (index - 1 == 0)
+        {
+            dir2.next -= 0x1000;
+        }
+        pageTail = pageTail->next;
+        pageTail->next = NULL;
+        pageInfor.virtualAddress -= 0x200000; // 2MB
+    }
+    dir2.usedAmount -= pageAmount;
+}
\ No newline at end of file
diff --git a/kernel/arch/arm/memory.c b/kernel/arch/arm/memory.c
new file mode 100644
index 0000000..9a247c8
--- /dev/null
+++ b/kernel/arch/arm/memory.c
@@ -0,0 +1,61 @@
+/**
+ * Name:
+ * Author: Benji Xu <benjixu2020@gmail.com>
+ * Date: 2022-02-26 02:01:26
+ * LastEditTime: 2022-02-26 02:17:15
+ * LastEditors: Benji Xu
+ * FilePath: /dolphin2/kernel/arch/arm/memory.c
+ * Description: This is paging for arm64
+ * 描述: 这是基于arm64的分页管理
+ * 虚拟地址的 0x3f200000～0x3f200000+0x1044 无法使用，注意
+ */
+
+#include "arm/memory.h"
+#include "arm/mapping.h"
+#include "printk.h"
+#include "debug.h"
+#include "stddef.h"
+#include "debug.h"
+
+uint64_t pageSize = 0x200000; // 2mb
+
+static struct page freeMemory;
+extern char end;
+
+void init_memory()
+{
+
+    printk("physical mem:%d\n", SIZE_MEM);
+
+    uint64_t startMemory = 0x400000;
+    uint64_t pages = SIZE_MEM / 2 - 2;
+    ASSERT(pages > 0, "init_page(): memory is too small (memory must bigger than 4 MB)");
+
+    uint64_t address = startMemory;
+    pageHead = startMemory;
+    for (uint32_t i = 0; i < pages - 1; i++)
+    {
+        address = link_page(address, pageSize);
+    }
+    pageTail = address;
+    pageTail->next = NULL;
+    
+    init_malloc(0, 0, 0, KERNEL);
+    malloc_page(4);
+    
+    free_page(2);
+    malloc_page(10);
+
+    /* test code */
+    uint64_t *test = 0x800000 + KERNEL_BASE;
+    uint64_t *test2 = 0x600000 + KERNEL_BASE;
+    *test = 12;
+    *test2 = 13;
+}
+
+uint64_t link_page(uint64_t address, uint64_t offset)
+{
+    struct page *p = address;
+    p->next = address + offset;
+    return address + offset;
+}
diff --git a/kernel/arch/arm/mmu.S b/kernel/arch/arm/mmu.S
new file mode 100644
index 0000000..01b2d38
--- /dev/null
+++ b/kernel/arch/arm/mmu.S
@@ -0,0 +1,136 @@
+.equ MAIR_ATTR, (0x44 << 8)
+.equ TCR_T0SZ,  (16) 
+.equ TCR_T1SZ,  (16 << 16)
+.equ TCR_TG0,   (0 << 14)
+.equ TCR_TG1,   (2 << 30)
+.equ TCR_VALUE, (TCR_T0SZ | TCR_T1SZ | TCR_TG0 | TCR_TG1)
+.equ PAGE_SIZE, (2*1024*1024)
+
+.global enable_mmu
+.global setup_vm
+
+
+enable_mmu:
+    adr x0, pgd_ttbr1
+    msr ttbr1_el1, x0
+
+    adr x0, pgd_ttbr0
+    msr ttbr0_el1, x0
+
+    ldr x0, =MAIR_ATTR
+    msr mair_el1, x0
+
+    ldr x0, =TCR_VALUE
+    msr tcr_el1, x0
+
+    mrs x0, sctlr_el1
+    orr x0, x0, #1
+    msr sctlr_el1, x0
+    
+    ret
+
+
+setup_vm:
+setup_kvm:
+    adr x0, pgd_ttbr1
+    adr x1, pud_ttbr1
+    orr x1, x1, #3
+    str x1, [x0]
+
+    adr x0, pud_ttbr1
+    mov x1, #0x200000
+    orr x1, x1, #3
+    str x1, [x0]
+
+    mov x2, #0x400000
+    mov x1, #0x200000
+    mov x0, #(1 << 10 | 1 << 2 | 1 << 0)
+
+loop1:
+    str x0, [x1], #8
+    add x0, x0, #PAGE_SIZE
+    cmp x0, x2
+    blo loop1
+
+    mov x2, #0x40000000
+    mov x0, #0x3f000000
+
+    mov x3, #0x200000
+    lsr x1, x0, #(21 - 3)
+    add x1, x1, x3
+
+    orr x0, x0, #1
+    orr x0, x0, #(1 << 10)
+
+loop2:
+    str x0, [x1], #8
+    add x0, x0, #PAGE_SIZE
+    cmp x0, x2
+    blo loop2
+
+    adr x0, pud_ttbr1
+    add x0, x0, #(1 * 8)
+    adr x1, pmd2_ttbr1
+    orr x1, x1, #3
+    str x1, [x0]
+
+    mov x2, #0x41000000
+    mov x0, #0x40000000
+
+    adr x1, pmd2_ttbr1
+    orr x0, x0, #1
+    orr x0, x0, #(1 << 10)
+
+loop3:
+    str x0, [x1], #8
+    add x0, x0, #PAGE_SIZE
+    cmp x0, x2
+    blo loop3
+
+
+setup_uvm:
+    adr x0, pgd_ttbr0
+    adr x1, pud_ttbr0
+    orr x1, x1, #3
+    str x1, [x0]
+
+    adr x0, pud_ttbr0
+    adr x1, pmd_ttbr0
+    orr x1, x1, #3
+    str x1, [x0]
+
+    adr x1, pmd_ttbr0
+    mov x0, #(1 << 10 | 1 << 2 | 1 << 0 )
+    str x0, [x1]
+
+    mov x2, #0x40000000
+
+loop4:
+    str x0, [x1], #8
+    add x0, x0, #PAGE_SIZE
+    cmp x0, x2
+    blo loop4
+
+    ret
+
+
+.balign 4096
+pgd_ttbr1:
+    .space 4096
+pud_ttbr1:
+    .space 4096
+pmd_ttbr1:
+    .space 4096
+pmd2_ttbr1:
+    .space 4096
+
+pgd_ttbr0:
+    .space 4096
+pud_ttbr0:
+    .space 4096
+pmd_ttbr0:
+    .space 4096
+
+
+
+	
\ No newline at end of file
diff --git a/kernel/arch/arm/register.c b/kernel/arch/arm/register.c
new file mode 100644
index 0000000..e543411
--- /dev/null
+++ b/kernel/arch/arm/register.c
@@ -0,0 +1,47 @@
+#include "stdint.h"
+#include "arm/register.h"
+
+void set_task_register(int pid, uint64_t functionAddress)
+{
+    registerList[pid].elr_el1 = functionAddress;
+    // registerList[pid].spsr_el1 =
+    registerList[pid].sp = 0x80000 - (pid * 0x1000);
+}
+
+void save_registers(struct trap_frame *curTask, struct trap_frame *tf, uint64_t elr_el1, uint64_t spsr_el1, uint64_t sp)
+{
+    curTask->x0 = tf->x0;
+    curTask->x1 = tf->x1;
+    curTask->x2 = tf->x2;
+    curTask->x3 = tf->x3;
+    curTask->x4 = tf->x4;
+    curTask->x5 = tf->x5;
+    curTask->x6 = tf->x6;
+    curTask->x7 = tf->x7;
+    curTask->x8 = tf->x8;
+    curTask->x9 = tf->x9;
+    curTask->x10 = tf->x10;
+    curTask->x11 = tf->x11;
+    curTask->x12 = tf->x12;
+    curTask->x13 = tf->x13;
+    curTask->x14 = tf->x14;
+    curTask->x15 = tf->x15;
+    curTask->x16 = tf->x16;
+    curTask->x17 = tf->x17;
+    curTask->x18 = tf->x18;
+    curTask->x19 = tf->x19;
+    curTask->x20 = tf->x20;
+    curTask->x21 = tf->x21;
+    curTask->x22 = tf->x22;
+    curTask->x23 = tf->x23;
+    curTask->x24 = tf->x24;
+    curTask->x25 = tf->x25;
+    curTask->x26 = tf->x26;
+    curTask->x27 = tf->x27;
+    curTask->x28 = tf->x28;
+    curTask->x29 = tf->x29;
+    curTask->x30 = tf->x30;
+    curTask->sp = sp;
+    curTask->spsr_el1 = spsr_el1;
+    curTask->elr_el1 = elr_el1;
+}
\ No newline at end of file
diff --git a/kernel/arch/arm/uart.c b/kernel/arch/arm/uart.c
new file mode 100644
index 0000000..caa7432
--- /dev/null
+++ b/kernel/arch/arm/uart.c
@@ -0,0 +1,40 @@
+#include "arm/uart.h"
+#include "arm/lib.h"
+#include "arm/handler.h"
+
+void puts(char *str){
+    while (*str != 0x00)
+	{
+		write_char(*str);
+		str++;
+	}
+}
+
+void write_char(unsigned char c)
+{
+    while (in_word(UART0_FR) & (1 << 5)) { }
+    out_word(UART0_DR, c);
+}
+
+unsigned char read_char(void)
+{
+    while (in_word(UART0_FR) & (1 << 4)) { }
+    return in_word(UART0_DR);
+}
+
+void write_string(const char *string)
+{
+    for (int i = 0; string[i] != '\0'; i++) {
+        write_char(string[i]);
+    }
+}
+
+void init_uart(void)
+{
+    out_word(UART0_CR, 0);
+    out_word(UART0_IBRD, 26);
+    out_word(UART0_FBRD, 0);
+    out_word(UART0_LCRH, (1 << 4) | (1 << 5) | (1 << 6));
+    out_word(UART0_IMSC, 0);
+    out_word(UART0_CR, (1 << 0) | (1 << 8) | (1 << 9));
+}
diff --git a/kernel/debug.c b/kernel/debug.c
index 309da42..8375a4e 100644
--- a/kernel/debug.c
+++ b/kernel/debug.c
@@ -1,5 +1,4 @@
 #include "debug.h"
-#include "amd64/put.h"
 #include "stdint.h"
 #include "printk.h"
 
diff --git a/kernel/drives/usb/aarch/amd64/makefile b/kernel/drives/usb/arch/amd64/makefile
similarity index 100%
rename from kernel/drives/usb/aarch/amd64/makefile
rename to kernel/drives/usb/arch/amd64/makefile
diff --git a/kernel/drives/usb/aarch/arm/makefile b/kernel/drives/usb/arch/arm/makefile
similarity index 100%
rename from kernel/drives/usb/aarch/arm/makefile
rename to kernel/drives/usb/arch/arm/makefile
diff --git a/kernel/kernel.c b/kernel/kernel.c
index 66d5186..fb71858 100644
--- a/kernel/kernel.c
+++ b/kernel/kernel.c
@@ -1,34 +1,43 @@
-/*
- * @Author: your name
- * @Date: 2021-10-29 21:06:10
- * @LastEditTime: 2021-11-13 01:10:14
- * @LastEditors: Please set LastEditors
- * @Description: In User Settings Edit
- * @FilePath: /dolphin2/kernel/kernel.c
+/** 
+ * Name: 
+ * Author: Benji Xu <benjixu2020@gmail.com>
+ * Date: 2021-11-04 03:56:41
+ * LastEditTime: 2022-01-22 05:39:33
+ * LastEditors: Benji Xu
+ * FilePath: /dolphin2/kernel/kernel.c
+ * Description: 
+ * 描述: 无论是x86还是arm cpu执行完引导区的代码以后就开始执行这里的代码。
  */
-
-
-
 #include "init.h"
 #include "stdint.h"
 #include "stdarg.h"
 #include "debug.h"
+#include "interruption.h"
+#include "printk.h"
 
 
 void kernel_init(void)
 {
   //  char* p = (char*)0xb8000;
 
-    __asm__ __volatile__("cli");
+     
     init_all();
-    __asm__ __volatile__("sti");
+
+    printk("hello world\n");
+
+    int a = 100;
+    a =200;
+    //ASSERT(3,2);
+  
+
+     printk("!!!!!!!!!!!!\n");    
     while (1)
     {
-        for (int i = 0; i < 10000000; i++)
+        for (int i = 0; i < 100; i++)
         {
             /* code */
         }
-      printk(" 0??0 ");
+      printk(" T000 ");
     }
     
     //__asm__ __volatile__("cli");
diff --git a/kernel/task.c b/kernel/task.c
new file mode 100644
index 0000000..28a41ad
--- /dev/null
+++ b/kernel/task.c
@@ -0,0 +1,140 @@
+/**
+ * Name: task.c
+ * Author: Benji Xu <benjixu2020@gmail.com>
+ * Date: 2022-01-20 12:21:48
+ * LastEditTime: 2022-03-11 23:55:12
+ * LastEditors: Benji Xu
+ * FilePath: /dolphin2/kernel/task.c
+ * Description: task scheduling fit into the x86 and arm.
+ * I suggest you pay more attention on set_task_register(),
+ * because only this function call the code having to do with the cpu arch.
+ * 描述: 任务调度代码，适用于x86和arm。你只需要注意set_task_register。
+ * 因为只有这个函数调用了和处理器架构相关的代码。
+ */
+#include "stdint.h"
+#include "printk.h"
+#include "task.h"
+#include "arm/memory.h"
+
+int tasksNum = 0;
+
+void test_print1()
+{
+    while (1)
+    {
+        for (int i = 0; i < 10000; i++)
+        {
+            /* code */
+        }
+
+        printk(" 1aa1 ");
+    }
+}
+
+void test_print2()
+{
+    while (1)
+    {
+        for (int i = 0; i < 10000; i++)
+        {
+            /* code */
+        }
+        printk(" 2bb2 ");
+    }
+}
+
+void test_print3()
+{
+    while (1)
+    {
+        for (int i = 0; i < 10000; i++)
+        {
+            /* code */
+        }
+        printk(" 3cc3 ");
+    }
+}
+
+/**
+ * @function: init_task
+ * @param [void]
+ * @return [void]
+ * description: 初始化进程所需要的环境，其实就是把kernel进程初始化为0号进程，并且把kernel进程设置为正在运行
+ */
+void init_task(void)
+{
+
+    char name[64] = "000000000";
+    for (int i = 0; i < 64; i++)
+    {
+        tasks[0].name[i] = name[i];
+    }
+    tasks[0].status = TASK_RUNNING;
+    tasks[0].type = KERNEL;
+    tasks[0].pid = 0;
+    set_task_register(0, 0);
+    p = &tasks[0];
+    tHead = p;
+    tHead->before = p;
+    tHead->next = p;
+    tasksNum = 1;
+
+    //测试代码
+    uint64_t print1 = &test_print1;
+    uint64_t print2 = &test_print2;
+    uint64_t print3 = &test_print3;
+    create_task("111111", KERNEL, print1 - KERNEL_BASE);
+    create_task("2222222", KERNEL, print2 - KERNEL_BASE);
+    create_task("33333333333", KERNEL, print3 - KERNEL_BASE);
+}
+
+void create_task(char *name, enum task_type type, uint64_t functionAddress)
+{
+    for (int i = 0; i < tasksNum; i++)
+    {
+        if (tasks[i].status == TASK_DIED)
+        {
+            p = &tasks[i];
+            set_task_status(name, p, functionAddress, type);
+            return;
+        }
+    }
+    tasksNum++;
+    link_task(&tasks[tasksNum - 1]);
+    set_task_status(name, &tasks[tasksNum - 1], functionAddress, type);
+}
+
+/**
+ * @function: set_task_status
+ * @param [char] *name: the name of the task
+ * @param [task_list] *p: the pointer of to set task
+ * @param [uint64_t] functionAddress: the task address
+ * @param [enum task_type] type: the type of the task
+ * @return [void]
+ * description: 设置任务的状态，其实就是初始化任务所需要的数据，还把一些初始值填入寄存器
+ */
+void set_task_status(char *name, struct task_list *p, uint64_t functionAddress, enum task_type type)
+{
+    for (int i = 0; i < 64; i++)
+    {
+        p->name[i] = name[i];
+    }
+    p->status = TASK_WAITTING;
+    p->pid = p->before->pid + 1;
+    set_task_register(p->pid, functionAddress);
+}
+
+/**
+ * @function: link_list
+ * @param [task_list] *tempTask: to set task's pointer
+ * @return [void]
+ * description: 将新任务的结构体加入双链表
+ */
+uint64_t link_task(struct task_list *tempTask)
+{
+    p->next = tempTask;
+    tempTask->before = p;
+    p = p->next;
+    p->next = tHead;
+    tHead->before = p;
+}
diff --git a/link/lds/link_arm.lds b/link/lds/link_arm.lds
index a460f25..ea8e05c 100644
--- a/link/lds/link_arm.lds
+++ b/link/lds/link_arm.lds
@@ -1,19 +1,27 @@
+ENTRY(start)
 SECTIONS
 {
-    . = 0x80000;
-    .text : { KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*) }
-    .rodata : { *(.rodata .rodata.* .gnu.linkonce.r*) }
-    PROVIDE(_data = .);
-    .data : { *(.data .data.* .gnu.linkonce.d*) }
-    .bss (NOLOAD) : {
-        . = ALIGN(16);
-        __bss_start = .;
-        *(.bss .bss.*)
-        *(COMMON)
-        __bss_end = .;
+    . = 0xffff000000080000;
+
+    .text : {
+        KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*)
+        *(.text)
+    }
+
+    .rodata : {
+        *(.rodata)
+    }
+
+    . = ALIGN(16);
+    .data : {
+        *(.data)
+    }
+
+    .bss : {
+        bss_start = .;
+        *(.bss)
+        bss_end = .;
     }
-    _end = .;
 
-   /DISCARD/ : { *(.comment) *(.gnu*) *(.note*) *(.eh_frame*) }
-}
-__bss_size = (__bss_end - __bss_start)>>3;
\ No newline at end of file
+    end = .;
+}
\ No newline at end of file
diff --git a/link/lds/link_x86.lds b/link/lds/link_x86.lds
index 114d5cd..8a74fb8 100644
--- a/link/lds/link_x86.lds
+++ b/link/lds/link_x86.lds
@@ -4,12 +4,9 @@ ENTRY(start)
 SECTIONS
 {
     . = 0x400000;
-#貌似是要使用绝对路径不知道为啥
-    .text.entry : {
-        /root/benjixu/dolphin2/build/amd64/start.o(.text)
-    }
 
     .text : {
+        KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*)
        *(.text)
     }
 
diff --git a/makefile b/makefile
index 849f5d2..36cb98d 100755
--- a/makefile
+++ b/makefile
@@ -5,19 +5,19 @@ export MKFILEFLAGS 				 += --no-print-directory
 export HEAD_PATH 		      	 = $(PROJECT_DIR)/include
 include config.mk
 
-ifeq ($(ARCH),x86)
-	AARCH					= aarch/amd64
+ifeq ($(target),x86)
+	AARCH					= arch/amd64
 	BUILD_PATH				= $(PROJECT_DIR)/build/amd64
 	SUFFIX					= asm
 	RUNNING_INSTURCTION     = qemu-system-x86_64 -cpu Skylake-Server -m $(VIRTUAL_MEMORY) -hda $(BUILD_PATH)/boot.img -boot d
 	DEBUG					= qemu-system-x86_64 -cpu Skylake-Server -m $(VIRTUAL_MEMORY) -hda $(BUILD_PATH)/boot.img -boot d -s -S 
 endif
-ifeq ($(ARCH),arm)
-	AARCH					= aarch/arm
+ifeq ($(target),arm)
+	AARCH					= arch/arm
 	BUILD_PATH				= $(PROJECT_DIR)/build/arm
 	SUFFIX					= S
-	RUNNING_INSTURCTION		= qemu-system-aarch64 -M raspi3 -kernel $(BUILD_PATH)/kernel8.img -serial stdio 
-	DEBUG					= qemu-system-aarch64 -M raspi3 -kernel $(BUILD_PATH)/kernel8.img -serial stdio -s -S 
+	RUNNING_INSTURCTION		= qemu-system-aarch64 -M raspi3 -m $(VIRTUAL_MEMORY) -kernel $(BUILD_PATH)/kernel8.img -serial stdio 
+	DEBUG					= qemu-system-aarch64 -M raspi3 -m $(VIRTUAL_MEMORY) -kernel $(BUILD_PATH)/kernel8.img -serial stdio -s -S 
 endif
 
 export AARCH
diff --git a/source/common.mk b/source/common.mk
index 9d82786..706e02f 100644
--- a/source/common.mk
+++ b/source/common.mk
@@ -8,32 +8,39 @@ OBJ		   += $(addprefix $(BUILD_PATH)/,$(SRCSASM:.$(SUFFIX)=.o))
 DEPS 		= $(addprefix $(DEPS_PATH)/,$(SRCS:.c=.d))
 OBJS 		= $(wildcard $(BUILD_PATH)/*.o)
 
-ifeq ($(ARCH),x86)
+ifeq ($(target),x86)
 NASM 		= nasm
 ASM_FLAGS   = -f elf64 -F dwarf #dwarf是开启汇编可调试的参数
-CC 			= gcc 
+CC 			= x86_64-linux-gnu-gcc 
 COPS		= -I$(HEAD_PATH) -std=c99 -mcmodel=large -ffreestanding -fno-stack-protector -mno-red-zone -w -g $(OPTIMIZATION)
 ASMOPS		= -I$(HEAD_PATH)
-LD 			= ld 
+LD 			= x86_64-linux-gnu-ld 
 #时刻要注意init.o是不是第一个被链接
 LDOPS 		= -nostdlib -T $(PROJECT_DIR)/link/lds/link_x86.lds -o
 KERNEL_ELF  = kernel8.elf
-OBJCOPY 	= objcopy -O binary
+OBJCOPY 	= x86_64-linux-gnu-objcopy -O binary
 DISASSEMBLY = -j .text -l -C -S -d -mi386:x86-64:intel $(DEBUG_FILE) $(PROJECT_DIR)/build/amd64/$(KERNEL_ELF) 
+OBJDUMP 	= x86_64-linux-gnu-objdump
 endif
 
-ifeq ($(ARCH),arm)
-CC			= aarch64-elf-gcc
-#CC			= aarch64-linux-gnu-gcc
+ifeq ($(target),arm)
+#编译安装的支持aarch64的gcc开启带调试选项，apt-get安装的默认不带调试功能，所以arm汇编无法调试
+#aarch64-elf-gcc是编译安装的，aarch-linux-gnu-gcc是apt-get安装的
+#CC			= /usr/local/cross-compiler/bin/aarch64-elf-gcc
+CC			= aarch64-linux-gnu-gcc
 #COPS 		= -Wall $(OPTIMIZATION) -nostdlib -nostartfiles -ffreestanding -I$(HEAD_PATH) -g -fno-stack-protector -nostdinc -c
-COPS 		= -Wall $(OPTIMIZATION) -nostdlib -nostartfiles -ffreestanding -I$(HEAD_PATH) -g -fno-stack-protector -c -w
-#-mgeneral-regs-only
-ASMOPS		= -I$(HEAD_PATH)
-LD			= aarch64-elf-ld
-#LD			= aarch64-linux-gnu-ld
+COPS 		= -Wall $(OPTIMIZATION) -nostdlib -nostartfiles -ffreestanding -I$(HEAD_PATH) -g -fno-stack-protector -c -w -mgeneral-regs-only -std=c99
+COPS 	   += -DMEM=$(VIRTUAL_MEMORY)
+ASMOPS		= -I$(HEAD_PATH) -g
+#LD			= /usr/local/cross-compiler/bin/aarch64-elf-ld
+LD			= aarch64-linux-gnu-ld
 LDOPS 		= -nostdlib -nostartfiles -T $(PROJECT_DIR)/link/lds/link_arm.lds -o
 KERNEL_ELF  = kernel8.elf
-OBJCOPY 	= aarch64-elf-objcopy -O binary
+OBJCOPY 	= /usr/local/cross-compiler/bin/aarch64-elf-objcopy -O binary
+DISASSEMBLY = -j .text -l -C -S -d $(DEBUG_FILE) $(PROJECT_DIR)/build/arm/$(KERNEL_ELF) 
+OBJDUMP		= /usr/local/cross-compiler/bin/aarch64-elf-objdump
+
+OBJCOPY 	= aarch64-linux-gnu-objcopy -O binary
 endif
 
 export CC
diff --git a/tools/HexToMB.py b/tools/HexToMB.py
index f2a7e9e..cd7b2db 100644
--- a/tools/HexToMB.py
+++ b/tools/HexToMB.py
@@ -73,7 +73,7 @@ def mbtohex():
 def main():
     hexnumber = ''
     print("")
-    print("请输入一个16进制的数字，我们将其转化为一个可读的内存大小，输入s反之，输入q退出:")
+    print("请输入一个16进制的数字，我们将其转化为一个可读的内存大小，输入s反之，输入h为接收十进制，输入q退出:")
     print("Please enter a hexnumber. We will convert it to comprehensible computer memory size，converse is entering 's'. enter 'q' exit:")
     hexnumber=input('Please input:')
     if hexnumber == 'q':
@@ -82,6 +82,10 @@ def main():
         exit()
     if hexnumber == '':
         main()
+    if hexnumber == 'h':
+        Dec = input("请输入十进制数字:")
+        Dec = int(Dec)
+        hexnumber = hex(Dec)
     if hexnumber == 's':
         hexnumber = ''
         mbtohex()
